# 22장 this ~ 24장 클로저	

---

## 22장 this
 
### 22.1 this 키워드

- `객체` : `상태(state)를 나타내는 프로퍼티`와
- `동작(behavior)`을 나타내는 `메서드를 하나의 논리적인 단위`로
- 묶은 `복합적인 자료구조`

- `동작을 나타내는 메서드` : `자신이 속한 객체의 상태`
- 즉 : `프로퍼티틀 참조하고 변경`할 수 있어야함
- `메서드가 자신이 속한 객체의 프로퍼티 참조`하기 위해
- 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 함

- `객체 리러터럴 방식으로 생성한 객체`의 경우
- `메서드 내부에서 자신이 속한 객체를 가리키는 식별자`를
- `재귀적으로 참조` 가능

```js
const circle = {
	// 프로퍼티 : 객체 고유의 상태 데이터
	radius: 5,
	// 메서드 : 상태 데이터를 참조하고 조작하는 동작
	getDiameter() {
		// 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드 참조하려면
		// 자신이 속한 객체인 circle을 참조할 수 있어야함
		return 2 * circle.radius;
	},
};

console.log(circle.getDiameter()); // 10
```

- `getDiameter 메서드` 내에서 → `메서드 내에서 메서드 자신이 속한 객체`를
- `가리키는 식별자 circle을 참조`하고 있음
- 이 참조 표현식이 `평가되는 시점` :
- `getDiameter 메서드가 호출되어 함수 몸체가 실행되는 시점`

- `객체 리터럴` : `circle 변수에 할당되기 직전에 평가`
- getDiameter 메서드가 `호출되는 시점`에는
- 이미 `객체 리터럴의 평가가 완료되어 객체가 생성`되었고
- `circle 식별자에 생성된 객체가 할당된 이후`
- 따라서 메서드 내부에서 circle 식별자 참조 가능

```js
function Circle(radius) {
    // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를
    // 가리키는 식별자를 알 수 없음
    ????.radius = radius;
}

Circle.prototype.getDiameter = function () {
    // 이 시점에는 생성자 함수 자신이 생성할
    // 인스턴스를 가리키는 식별자를 알 수 없음
    return 2 * ????.radius;
}

// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의
const circle = new Circle(5);
```

- `생성자 함수 내부` : `프로퍼티`, `메서드`를 `추가`하기 위해
- `자신이 생성할 인스턴스를 참조`할 수 있어야함
- 하지만 : `생성자 함수에 의한 객체 생성 방식` →
- 1. `생성자 함수를 정의`
- 2. `new 연산자와 함께 생성자 함수`를 호출
- 위와 같은 단계가 필요

> 생성자 함수 → 인스턴스 생성 : 생성자 함수 존재

- `생성자 함수를 정의`하는 시점 : `인스턴스를 생성 이전`
- `식별자를 알 수 없음`
- 자신이 속한 객체 또는 `자신이 생성할 인스턴스`를
- `가리키는 특수한 식별자`가 필요
- 이를 위해 JS : `this라는 특수한 식별자 제공`

- `this` : 자신이 속한 객체, 자신이 생성할 인스턴스를 가리키는
- `자기 참조 변수(self-referencing variable)`
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의
- `프로퍼티, 메서드를 참조 가능`

- `this` : `JS엔진에 의해서 암묵적으로 생성`
- `코드 어디서든 참조가 가능`
- 함수를 호출 : `arguments 객체`, `this`가 `암묵적으로 함수 내부 전달`
- 함수 내부 : `arguments 객체를 지역 변수처럼`
- `사용`할 수 있는 것처럼 → `this 또한 지역 변수처럼 사용`가능

> 단 : this가 가리키는 값 : this 바인딩의 경우 함수 호출 방식에 의해서
> 동적으로 결정됨

- `this 바인딩`
- `바인딩` : `식별자와 값을 연결하는 과정`을 의미함
- `변수 선언` : 변수 이름, 확보된 메모리 공간의 `주소를 바인딩`
- `this 바인딩` : `this`와 `this가 가리킬 객체를 바인딩` 하는 것

```js
// 객체 리터럴
const Circle = {
	radius: 5,
	getDiameter() {
		// this는 메서드를 호출한 객체를 가리킴
		return 2 * this.radius;
	},
};

console.log(circle.getDiameter()); // 10
```

- `객체 리터럴의 메서드 내부`에서의 `this` :
- `메서드를 호출한 객체` → circle을 가리킴

```js
// 생성자 함수
function Circle(radius) {
	// this는 생성자 함수가 생성할 인스턴스를 가리킴
	this.radius = radius;
}

Circle.prototype.getDiameter = function () {
	// this는 생성자 함수가 생성할 인스턴스를 가리킴
	return 2 * this.radius;
};

// 인스턴스 생성
const circle = new Circle(5);
console.log(circle.getDiameter()); // 10
```

- `생성자 함수 내부의 this` : `생성자 함수가 생성할 인스턴스 가리킴`
- `this` : `상황에 따라 가리키는 대상이 다름`

- JAVA, C++ 같은 클래스 기반 언어 : this
- 언제나 클래스가 생성하는 인스턴스를 가리킴

- JS this : 함수가 호출되는 방식에 따라
- this에 바인딩될 값 :
- this 바인딩이 동적으로 결정됨

> strict mode 또한 this 바인딩에 영향을 줌

- this는 코드 어디에서든 참조 가능 → 전역에서도 함 내부에서도 참조 가능

```js
// this : 어디서든지 참조 가능
// 전역에서 this : 전역 객체 window 가리킴
console.log(this); //window

function square(number) {
	// 일반 함수 내부에서 this :
	// 전역 객체 window 가리킴
	console.log(this); // window
	return number * number;
}

square(2);

const person = {
	name: 'Lee',
	getName() {
		// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킴
		console.log(this); // {name: "Lee", getName: f}
		return this.name;
	},
};
console.log(person.getName()); // Lee

function Person(name) {
	this.name = name;
	// 생성자 함수 내부에서 this :
	// 생성자 함수가 생성할 인스턴스를 가리킴
	console.log(this); // Person {name: "Lee"};

	const me = new Person('Lee');
}
```

- 하지만 `this` : `객체의 프로퍼티나 메서드를 참조`하기 위한
- `자기 참조 변수`이므로
- 일반적으로 `객체의 메서드` 또는 `생성자 함수 내부`에서만 의미
- `strict mode`가 적용된 `일반 함수 내부의 this` : `undefined가 바인딩`
- 일반 함수 내부에서는 `this를 사용할 필요가 없기 때문`

### 22.2 함수 호출 방식과 this 바인딩

- `this 바인딩(바인딩될 값)` : `함수 호출 방식`
- `함수가 어떻게 호출`되었는지에 따라
- `동적으로 결정`됨

- 렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.
- 함수의 상위 스코프를 결정하는 방식인
- `렉시컬 스코프(lexical scope)` : `함수 정의가 평가`되어
- `함수 객체가 생성되는 시점`에 `상위 스코프를 결정`

- `this 바인딩` : `함수 호출 시점에 결정`

- 주의점
- 함수도 다양한 방식으로 호출 가능
- 함수 호출 방식
- 1. `일반 함수` 호출
- 2. `메서드` 호출
- 3. `생성자 함수` 호출
- 4. `Function.prototype.apply/call/bind 메서드`에 의한 `간접 호출`

```js
// this 바인딩 : 함수 호출 방식에 따라 동적으로 결정
const foo = function () {
	console.dir(this);
};

// 동일한 함수도 다양한 방식으로 호출 가능

// 1. 일반 함수 호출
// foo 함수를 일반적인 방식으로 호출
// foo 함수 내부의 this : 전역 객체 window
foo(); //window

// 2. 메서드 호출
// foo 함수를 프로퍼티 값으로 할당하여 호출
// foo 함수 내부의 this :
// 메서드를 호출한 객체 obj
const obj = { foo };
obj.foo(); // obj

// 3. 생성자 함수 호출
// foo 함수를 new 연산자와 함께 생성자 함수로 호출
// foo 함수 내부의 this :
// 생성자 함수가 생성한 인스턴스를 가리킴
new foo(); // foo{}

// 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출
// foo 함수 내부의 this :
// 인수에 의해 결정
const bar = { name: 'bar' };

foo.call(bar); // bar
foo.apply(bar); // bar
foo.bind(bar)(); // bar
```

> 함수 호출 방식에 따라 this 바인딩이 어떻게 결정되는지 학습

#### 22.2.1 일반 함수 호출

- 기본적으로 `this` : `전역 객체(global object)가 바인딩` 됨

```js
function foo() {
	console.log("foo's this: ", this); // window
	function bar() {
		console.log("bar's this: ", this); // window
	}
	bar();
}
foo();
```

- 위 예제외 같이 `전역 함수는 물론`이고
- `중첩 함수` → `일반 함수로 호출`하게되면
- `함수 내부의 this` : `전역 객체가 바인딩`됨

- 다만 this의 경우 객체의 프로퍼티나 메서드 참조용
- `일반 함수에서는 의미가 없음`

> strict mode : undefined 바인딩

- `메서드 내에서 정의한 중첩 함수` :
- `일반 함수로 호출`되면
- 중첩 함수 내부의 this :
- 전역 객체가 바인딩됨

```js
// var 키워드로 선언한 전역 변수 value
// 전역 객체의 프로퍼티
var value = 1;
// const 키워드로 선언한 전역 변수 value :
// 전역 객체의 프로퍼티가 아님
// const value = 1;

const obj = {
    value : 100,
    foo() {
        console.log("foo's this: ", this); // {value: 100, foo: f}
        console.log("foo's this.value" this.value); // 100

        // 메서드 내부에서 정의한 중첩 함수
        function bar() {
            console.log("bar's this: ", this); // window
            console.log("bar's this.value: ", this.value); //1
        }
    }

    // 메서드 내에서 정의한 중첩 함수도
    // 일반 함수로 호출하게 되면 this :
    // window 전역 객체가 바인딩됨
    bar();
};

boj.foo();
```

- `콜백 함수` → `일반 함수로 호출`된다면
- `콜백 함수 내부 this` : `전역 객체가 바인딩`

> 어떤 함수라도 일반 함수 호출 → this에 전역 객체 바인딩

- 하지만 `메서드 내에서 정의한 중첩 함수` 또는
- `메서드에게 전달한 콜백 함수(보조 함수)`가
- 일반 함수로 호출 될 때 메서드 내의 중첩 함수, 콜백함수의
- `this` → `전역 객체를 바인딩` 하는 것은 `문제`가 있음

- `중첩`, `콜백` → `헬퍼 함수` 역할
- 외부 함수의 일반 로직을 대신하는 경우가 대부분
- `일반 함수의 호출은 이를 망침`

> 메서드 내부 중첩, 콜백 함수 this 바인딩 일치법

```js
var value = 1;

const obj = {
	value: 100,
	foo() {
		// this 바인딩(obj)를 변수 that에 할당
		const that = this;

		// 콜백 함수 내부에서 this 대신 that을 참조
		setTimeout(function () {
			console.log(that.value); // 100
		}, 100);
	},
};
obj.foo();
```

- 위 방법 이외에도 JS : this를 `명시적으로 바인딩` 할 수 있는
- 1. `Function.prototype.apply`
- 2. `Function.prototype.call`
- 3. `Function.prototype.bind`

```js
var value = 1;

const obj = {
	value: 100,
	foo() {
		// 콜백 함수에 명시적으로 this를 바인딩
		setTimeout(
			function () {
				console.log(this.value); // 100
			}.bind(this),
			100
		);
	},
};
obj.foo();
```

> 또는 화살표 함수를 사용해서 this 바인딩 일치 가능

```js
var value = 1;

const obj = {
	value: 100,
	foo() {
		setTimeout(() => console.log(this.value), 100); //100
	},
};
obj.foo();
```

#### 22.2.2 메서드 호출

- 메서드 내부의 `this` : `메서드를 호출한 객체`
- 즉 : 메서드를 호출할 때
- 메서드 이름 앞의 `마침표(.)` 연산자 앞에 기술한 객체 바인딩
- 주의점 : 메서드 내부의 this는 메서드를 소유한 객체가 아닌
- `메서드를 호출한 객체에 바인딩` 된다는 점

```js
const person = {
	name: 'Lee',
	getName() {
		// 메서드 내부의 this : 메서드를 호출한 객체에 바인딩
		return this.name;
	},
};

// 메서드 getName을 호출한 객체 : person임
console.log(person.getName()); // Lee
```

- 위 에제의 `getName 메서드` : `person 객체의 메서드로 정의`
- `메서드` : `프로퍼티에 바인딩된 함수`
- person 객체의 `getName 프로퍼티가 가리키는 함수 객체` :
- `person 객체에 포함된 것이 아닌`
- → `독립적으로 존재`하는 `별도의 객체`

> getName 프로퍼티가 함수 객체를 가리키고 있을 뿐
> 메서드는 객체에 포함된 것이 아닌 독립적으로 존재하는 별도의 객체

- 따라서 `getName 프로퍼티가 가리키는 함수 객체`
- 즉 : `getName 메서드` → `다른 객체의 프로퍼티에 할당`하는 것
- `다른 객체의 메서드`가 될 수 도 있고
- `일반 변수로 할당`하여 `일반 함수로 호출 가능`

```js
const anotherPerson = {
	name: 'Kim',
};
// getName 메서드를 anotherPerson 객체의 메서드로 할당
anotherPerson.getName = person.getName;

// getName 메서드를 호출한 객체 : anotherPerson임
console.log(anotherPerson.getName()); // Kim

// getName 메서드를 변수에 할당
const getName = person.getName;

// getName 메서드를 잉ㄹ반 함수로 호출
console.log(getName()); // ''
// 일반 함수로 호출된 getName 함수 내부의 this.name
// 브라우저 환경에서 window.name과 같게 됨
// 브라우저에서의 window.name → 창 이름을 나타내는 빌트인 프로퍼티
// 기본값 : ''
// Node.js 환경에서 this.name : undefined임
```

- 따라서 `메서드 내부의 this` : 프로퍼티로 메서드를 가리키고 있는
- 객체와는 관계가 없고
- `메서드를 호출한 객체에 바인딩`됨

- `프로토타입 메서드 내부`에서 사용된 `this` :
- 일반 메서드와 마찬가지로 해당 메서드를 `호출한 객체`에
- `바인딩`되게 됨

```js
function Person(name) {
	this.name = name;
}

Person.prototype.getName = function () {
	return this.name;
};

const me = new Person('Lee');

// getName 메서들르 호출한 객체 : me
console.log(me.getName()); // 1. Lee

Person.prototype.name = 'Kim';

// getName 메서드를 호출한 객체 : Person.prototype
console.log(Person.prototype.getName()); // 2. Kim
```

- 1의 경우 `메서드를 호출한 객체는 me`임
- `getName 메서드 내부의 this는 me를 가리키며`
- `this.name`은 `'Lee'`임
- 2의 경우 getName 메서드를 호출한 객체 : Person.prototype임
- `Person.prototype`도 `객체`이며 `직접 메서드를 호출 가능`
- 따라서 `getName 메서드 내부`의 this는
- `Person.prototype`을 가리키며 this.name은 'Kim'임

#### 22.2.3 생성자 함수 호출

- 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩

```js
// 생성자 함수
function Circle(radius) {
	// 생성자 함수 내부의 this는 생성자 함수가
	// 생성할 인스턴스를 가리킴
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
}

// 반지름이 5인 Circle 객체를 생성
const circle1 = new Circle(5);
// 반지름이 10인 Circle 객체를 생성
const circle2 = new Circle(10);

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

- 17.2 생성자 함수에서 보았듯
- `생성자 함수` : 이름 그대로 `객체(인스턴스)를 생성하는 함수`
- `일반 함수와 동일한 방법`으로 `생성자 함수를 정의`하고
- `new 연산자와 함께 호출`하면
- 해당 함수는 `생성자 함수로 동작`하게 됨
- 만약 new 연산자와 함께 생성자 함수를 호출 안하면
- 그냥 `일반 함수로 동작`하게 됨

```js
// new 연산자와 함께 호출하지 않으면
// 생성자 함수로 동작 X
// 일반적인 함수의 호출
const circle3 = Circle(15);

// 일반 함수로 호출된 Circle에는 반환문이 없으므로
// 암묵적으로 undefined를 반환함
console.log(circle3); // undefined

// 일반 함수로 호출된 Circle 내부의 this는 전역 객체를 가리킴
console.log(radius); // 15
```

#### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

- `apply`, `call`, `bind` 메서드 :
- `Function.prototype`의 메서드
- 이들 메서드 : `모든 함수가 상속받아 사용 가능`

- `Function.prototype.apply`, `Function.prototype.call` 메서드 :
- `this로 사용할 객체`와 `인수 리스트를 인수`로 전달받아
- `함수를 호출`하게 됨

```js
Function.prototype.apply(thisArg[, argsArray]);

Function.prototype.call(thisArg[, arg1[, arg2[, ...]]]);
```

- 예제

```js
function getThisBinding() {
	return this;
}

// this로 사용할 객체
const thisArg = { a: 1 };

console.log(getThisBinding()); // window

// getThisBinding 함수를 호출하면서
// 인수로 전달할 객체를
// getThisBinding 함수의 this에 바인딩
console.log(getThisBinding.apply(thisArg)); // {a: 1}
console.log(getThisBinding.call(thisArg)); // {a: 1}
```

- `apply, call 메서드의 본질적인 기능` :
- `함수를 호출`하는 것
- 함수를 호출하면서 `첫 번째 인수`로
- 전달한 특장 객체의 호출한 함수의
- `this를 바인딩`함

- `apply, call 메서드는 호출할 함수`에
- `인수를 전달하는 방식`만 다를 뿐
- `동일하게 동작`하게 됨
- ex) `호출할 함수 getThisBinding 함수`에
- `인수를 전달하지 않음`
- apply, call 메서드를 통해 `getThisBinding 함수`를
- `호출하면서 인수를 전달`

```js
function getThisBinding() {
	console.log(arguments);
	return this;
}

// this로 사용할 객체
const thisARg = { a: 1 };

// getThisBinding 함수를 호출하면서
// 인수로 전달할 객체를 getThisBinding 함수에 바인딩
// apply 메서드 : 호출할 함수의 인수를 배열로 묶어 전달
console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
// {a : 1}

// call 메서드 : 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달
console.log(getThisBinding.call(thisArg, 1, 2, 3));
// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
// {a : 1}
```

- `apply 메서드` : `호출할 함수의 인수를 배열로 묶어 전달`
- `call 메서드` : `인수를 쉼표로 구분`한 `리스트 형식으로 전달`
- 이처럼 `apply와 call 메서드` : `호출할 함수에 인수를 전달 방식`만 다를 뿐
- `this로 사용할 객체`를 전달 → `함수를 호출하는 것은 동일`

```js
function convertArgsToArray() {
	console.log(arguments);

	// arguments 객체를 배열로 변환
	// Array.prototype.slice를 인수 없이 호출하면
	// 배열의 복사본을 생성하게 됨
	const arr = Array.prototype.slice.call(arguments);
	// const arr = Array.prototype.slice.apply(arguments);
	console.log(arr);

	return arr;
}
convertArgsToArray(1, 2, 3); // {1, 2, 3}
```

- 아직 배열에 대한 학습은 하지 않았음 → 추후에 설명

> Function.prototype.bind 메서드 : apply, call 메서드와는 달리
> 함수를 호출하지 않고 this로 사용할 객체만 전달

```js
function getThisBinding() {
	return this;
}

// this로 사용할 객체
const thisArg = { a: 1 };

// bind 메서드 : 함수에 this로 사용할 객체를 전달
// bind 메서드 : 함수를 호출하지는 않음
console.log(getThisBinding.bind(thisArg)); // getThisBinding
// bind 메서드 : 함수를 호출하지는 않으므로 명시적 호출
console.log(getThisBinding.bind(thisArg)()); // {a : 1}
```

- `bind 메서드` : `메서드의 this`, `내부의 중첩함수 또는 콜백함수`의
- this가 `불일치하는 문제 해결`!!!

```js
const person = {
	name: 'Lee',
	foo(callback) {
		// 1
		setTimeout(callback, 100);
	},
};

person.foo(function () {
	console.log(`Hi my name is ${this.name}`); // 2 Hi my name is
	// 일반 함수로 호출된 콜백 함수 : 브라우저환경 window.name
	// 브라우저 window.name 기본 값 : ''
	// Node.js 환경에서 this.name : undefined
});
```

> 이런 경우에 대해서 bind를 사용가능

```js
const person = {
	name: 'Lee',
	foo(callback) {
		// bind 메서드로 callback 함수 내부의 this 바인딩을 전달
		setTimeout(callback.bind(this), 100);
	},
};

person.foo(function () {
	console.log(`Hi! my name is ${this.name}`); // good work
});
```

> this 바인딩 동적 결정

| 함수 호출 방식                                                   | this 바인딩                                                                  |
| ---------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 일반 함수 호출                                                   | 전역 객체                                                                    |
| 메서드 호출                                                      | 메서드를 호출한 객체                                                         |
| 생성자 함수 호출                                                 | 생성자 함수가 (미래에) 생성할 인스턴스                                       |
| Function.prototype.apply/call/bind <br/> 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 <br/> 첫 번째 인수로 전달한 객체 |

---

## 23. 실행 컨텍스트

- `실행 컨텍스트(execution context)` : JS 동작 원리를 담고 있는 핵심 개념
- 실행 컨텍스트 바르게 이해 → JS가
- 1. 식별자와 식별자에 바인딩 값(식별자 바인딩)을 관리하는 방법
- 2. 호이스팅이 발생하는 이유
- 3. 클로저의 동작 방식
- 4. 태스크 큐와 함께 동작하는 이벤트 핸들러
- 5. 비동기 처리의 동작 방식 이해 가능

### 소스코드의 타입

- ECMAScript 사양 : 소스코드(ECMAScript code)를 4가지 타입으로 구분
- 4가지 타입의 소스코드는 실행 컨텍스트를 생성

| 소스코드의 타입          | 설명                                                                                        |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| 전역 코드(global code)   | 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함 X                |
| 함수 코드(function code) | 함수 내부에 존재하는 소스코드를 말함. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 포함 X |
| eval 코드(eval coe)      | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 코드를 말함                         |
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드 포함 X               |

- `소스코드(실행 가능한 코드)`를 `4가지 타입으로 구분` 이유 :
- 소스코드의 타입에 따라 `실행 컨텍스트를 생성하는 과정`과
- `관리 내용`이 다르기 때문

1. 전역 코드

- `전역 코드` : `전역 변수를 관리`하기 위해 최상위 스코프인 `전역 스코프를 생성`
- `var 키워드`로 선언된 `전역 변수`, `함수 선언문`으로 정의된 `전역 함수`를
- `객체의 프로퍼티와 메서드로 바인딩`하고, `참조`하기 위해 `전역 객체와 연결`
- 이를 위해 `전역 코드가 평가` → `전역 실행 컨텍스트`가 생성

2. 함수 코드

- `함수 코드` : `지역 스코프`를 생성, `지역 변수`, `매개변수`, `arguments 객체를 관리` 해야 함
- 생성한 지역 스코프 → `전역 스코프에서 시작하는 스코프 체인의 일원`으로 연결
- 이를 위해 `함수 코드가 실행` → `함수 실행 컨텍스트`가 생성

3. eval 코드

- `eval 코드` : `strict mode`에서 `자신만의 독자적인 스코프`를 생성
- 이를 위해 `eval 코드 동작` → `eval 실행 컨텍스트`가 생성

4. 모듈 코드

- `모듈 코드`는 `모듈별로 독립적인 모듈 스코프`를 생성
- 이를 위해 `모듈 코드가 평`가되면 `모듈 실행 컨텍스트 생성`

### 23.2 소스코드의 평가와 실행

- `모든 소스코드` : `실행에 앞서 평가 과정`을 거치며
- `코드를 실행하기 위한 준비`를 함
- `JS엔진`은 소스코드를 2개의 과정
- 1. `소스코드의 평가`
- 2. `소스코드의 실행` 과정으로 나누어서 처리

- `소스코드 평가` 과정 : 1. `실행 컨텍스트를 생성`
- 2. 변수, 함수등의 `선언문`만 `먼저 실행` → `생성된 변수`나
- `함수 식별자`를 `키`로 `실행 컨텍스트가 관리`하는
- 스코프(`렉시컬 환경 레코드`)에 등록함

- `소스코드 평가 과정 끝`나면
- 비로소 선언문을 제외한 `소스코드가 순차적으로 실행`
- 즉 : `런타임`이 `실행`
- `소스코드 실행`에 `필요한 정보`
- 즉 : `함수의 참조`를 `실행 컨텍스트가 관리하는 스코프`에서
- `검색해서 취득`
- `변수 값의 변경` 등 소스코드의 `실행 결과` → 다시 실행 컨텍스트가
- `관리하는 스코프에 등록`됨

```js
var x;
x = 1;
```

- 다음과 같은 예제에서 `JS 엔진` :
- `2개의 과정`으로 나누어 처리
- 1. `소스코드 평가` 과정 → `변수 선언문` `var x;` 실행
- 생성된 변수 식별자 x → `실행 컨텍스트가 관리`하는
- `스코프에 등록` 후 → `undefined로 초기화`

- `소스코드 평가 과정이 끝`나면 → `비로소 소스코드 실행 과정`
- `변수 선언문` `var x;`는 `소스코드 평가 과정에서 이미 실행 완료`
- 따라서 → 소스코드 `실행` 과정 → `변수 할당문` `x=1;`만 `실행`
- `변수에 값을 할당`하려면 `먼저 x 변수가 선언된 변수`인지 `확인`

- 이를 위해 `실행 컨텍스트`가 관리하는 스코프에
- x 변수가 `등록되어 있는지 확인`
- 다시 말해 : x 변수가 선언된 변수인지 확인
- 등록되어 있는 경우 x 변수 : `평가 과정에서 선언문이 실행`되어 등록된 변수
- x가 선언된 변수라면 : `값을 할당`하고 → `할당 결과를 실행 컨텍스트에 등록, 관리`

> 1. 소스코드 평가 : 선언문 실행 후 스코프 등록
> 2. 소스코드 실행 : 변수 할당문 실행
>    실행 컨텍스트에 등록되어 있는지 확인 후 할당

### 23.2 실행 컨텍스트의 역할

- 다음 예제 : 전역 코드, 함수 코드로 구성
- JS가 이 예제를 어떻게 평가하고 실행할지 생각

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
	const x = 10;
	const y = 20;

	// 메서드 호출
	console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

#### 1. 전역 코드 평가

- 전역 코드 실행에 앞서
- 먼저 전역 코드 평가 과정을 거치며
- `전역 코드를 실행`하기 위한 `준비`를 함
- `소스코드 평가 과정` : `선언문만 먼저 실행`
- 전역 코드의 `변수 선언문`, `함수 선언문`이 먼저 실행
- 그 결과 : 생성된 1. `전역 변수`, 2. `전역함수`가
- `실행 컨턱스트가 관리`하는 → `전역 스코프`에 등록
- 이때 var 키워드로 선언된 `전역 변수와 함수 선언문`으로
- 정의된 `전역 함수` : `전역 객체의 프로퍼티와 메서드`가 됨

#### 2. 전역 코드 실행

- `전역 코드 평가 과정 끝` →
- `런타임이 시작`되어 `전역 코드가 순차적으로 실행`
- `전역 변수에 값이 할당`되고 `함수가 호출`됨
- `함수가 호출`되면 순차적으로 실행되던
- 전역 코드의 `실행을 일시 중단`
- `코드 실행 순서를 변경`하여 `함수 내부로 진입`

#### 3. 함수 코드 평가

- 함수 호출에 의해 : `코드 실행 순서가 변경`되어
- 함수 내부로 진입하면 → 함수 내부의 문들을
- 실행하기에 앞서 `함수 코드 평가 과정`을 거치며
- `함수 코드를 실행하기 위한 준비`를 함
- `매개변수`와 `지역 변수 선언문`이 `먼저 실행`

- 그 결과 : `생성된 매개변수`와 `지역 변수`가
- `실행 컨텍스트가 관리`하는 `지역 스코프에 등록`
- 함수 내부에서 `지역 변수처럼 사용할 수 있는`
- `arguments 객체`가 생성되어
- `지역 스코프에 등록`, `this 바인딩 결정`

#### 4. 함수 코드 실행

- 함수 코드 과정이 끝나면
- `런타임 시작` → `함수 코드가 순차적으로 실행`됨
- 이때 `매개변수`와 `지역 변수에 값이 할당`
- `console.log` `메서드가 호출`

- `console.log` 메서드 호출하기 위해서
- 먼저 식별자인 console → `스코프 체인을 통해 검색`
- 이를 위해 함수 코드의 지역 스코프 :
- `상위 스코프인 전역 스코프와 연결`되어야 함

- 하지만 console 식별자 :
- `스코프 체인 등록 X` → `전역 객체 프로퍼티`로 존재
- 이는 `전역 객체의 프로퍼티가 마치 전역 변수`처럼
- `전역 스코프를 통해 검색 가능`해야 한다는 것을 의미

- `log 프로퍼티`를 console 객체의 프로토타입 체인을 통해 검색
- `console.log` 메서드에 인수로 전달된 표현식
- `a + x + y`가 평가
- a, x, y 식별자 : 스코프 체인을 통해 검색
- `console.log` 메서드의 실행이 종료
- 함수 코드의 실행 과정 종료되고, `함수 호출 이전으로 되돌아가`
- `전역 코드의 실행을 계속`하게 됨

> 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 관리 필요

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스)를

   - 1) `스코프를 구분하여 등록`하고
   - 2) `상태 변화(식별자에 바인딩된 값의 변화)`를
   - `지속적으로 관리` 가능해야 함

2. `스코프를 중첩 관계에 의해 스코프 체인`을 형성

   - 스코프 체인을 통해 → `상위 스코프로 이동`
   - `식별자를 검색`할 수 있어야 함

3. 현재 실행 중인 코드의 `실행 순서를 변경`
   - (함수 호출에 의한 실행 순서 변경)
   - 할 수 있어야 하며
   - `원상복구도 가능`해야 함

- 이 모든 것을 관리하는 것이 : 실행 컨텍스트

- `실행 컨텍스트` : 소스코드를 실행하는데
- 1. `필요한 환경을 제공`하고
- 2. `실행 결과를 실제로 관리`하는 영역

- `구체적으로 실행 컨텍스트` :
- 1. `식별자(변수, 함수, 클래스)`를 `등록`, `관리`하고
- 2. `스코프와 코드 실행 순서` 관리를 구현한 `내부 매커니즘`
- `모든 코드` : `실행 컨텍스트를 통해 실행되고 관리`

- `식별자, 스코프` : `실행 컨텍스트의 렉시컬 환경`으로 관리
- 코드 `실행 순서` : `실행 컨텍스트 스택`으로 관리

### 23.4 실행 컨텍스트 스택

- 다음 예제

```js
const x = 1;

function foo() {
	const y = 2;

	function bar() {
		const z = 3;
		console.log(x + y + z);
	}
	bar();
}

foo(); // 6
```

- 위 예제 : `소스코드의 타입으로 분류`할 때
- `전역 코드, 함수 코드`로 이루어져 있음
- JS엔진 : `먼저 전역 코드를 평가`하여
- `전역 실행 컨텍스트를 생성`함
- 함수가 호출되면 `함수 코드를 평가`하여
- `함수 실행 컨텍스트를 생성`

- 생성된 실행 컨텍스트 : `스택 자료구조로 관리`
- 이를 → 스택 컨텍스트 스택
- 코드가 실행되는 시간의 흐름에 따라
- 실행 컨텍스트에 push, pop 됨

#### 1. 전역 코드의 평가와 실행

- `JS엔진` : 먼저 `전역 코드를 평가`하여
- `전역 실행 컨텍스트를 생성`하고
- 실행 컨텍스트 스택에 푸시함
- 전역 변수 x, `전역 함수 foo는 전역 실행 컨텍스트에 등록`
- `전역 코드가 실행되기 시작`하여
- 전역 변수 x에 `값이 할당`, `전역 함수` foo가 `호출`

#### 2. foo 함수 코드의 평가와 실행

- `전역 함수 foo가 호출` → 전역 코드의 `실행은 일시 중단`
- `코드의 제어권`이 : `foo 함수 내부로 이동`하게 됨
- `JS엔진` : `foo 함수 내부의 코드를 평가`하여 →
- 1. `foo 함수 실행 컨텍스트를 생성`
- 2. `실행 컨텍스트 스택에 푸시`
- foo 함수의 지역 변수 y와 중첩 함수 bar가
- foo 함수 실행 컨텍스트에 등록됨
- 이후 foo 함수 코드가 실행되기 시작하며 지역 변수 y 할당, 중첩함수 호출

#### 3. bar 함수 코드의 평가와 실행

- 중첩 함수 `bar가 호출되면 foo 함수 코드의 실행`은
- 일시 중단되고, 코드의 제어권이 bar 함수 내부로 이동함
- `JS엔진` : `bar 함수 내부의 함수 코드를 평가`하여
- `bar 함수 실행 컨텍스트를 생성`하고
- `실행 컨텍스트 스택에 푸시`
- `bar 함수의 지역 변수` z : `bar 함수 실행 컨텍스트`에 등록
- bar 함수 코드가 실행되기 시작하여
- 지역 변수 z에 값이 할당, console.log 메서드를 호출한 이후
- bar 함수는 종료

#### 4. foo 함수 코드로 복귀

- bar 함수가 종료되면
- 코드의 제어권 : 다시 foo 함수로 이동
- 이때 : JS엔진 → bar 함수 실행 컨텍스트를
- 실행 컨텍스트 스택에서 팝하여 제거함
- 결국 foo 함수 더 이상 실행할 코드가 없어서 종료

#### 5. 전역 코드로 복귀

- foo 함수가 종료되면
- 코드의 제어권 : 다시 전역 코드로 이동하게 됨
- JS 엔진 : foo 함수 실행 컨텍스트 팝하여 제거
- 결국 실행 컨텍스트 스택에는 아무것도 남아있지 않게됨

### 23.5 렉시컬 환경

- `렉시컬 환경(Lexical Environment)` :
- 1. `식별자`와 2. `식별자에 바인딩된 값`
- 그리고 3. `상위 스코프에 대한 참조를 기록하는 자료구조`
- 실행 컨텍스트를 구성하는 컴포넌트임
- 실행 컨텍스트 스택 : 코드의 실행 순서를 관리한다면
- 렉시컬 환경 : 스코프와 식별자를 관리

- `렉시컬 환경` : `키와 값을 갖는 객체 형태의 스코프`
- (전역, 함수, 블록 스코프)를 생성하여
- `식별자 → 키로 등록`하고
- `식별자에 바인딩된 값을 관리`
- 즉 : 렉시컬 환경은 스코프를 구분하여
- 식별자를 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체

- 실행 컨텍스트 :
- 1. `LexicalEnvironment 컴포넌트`
- 2. `VariableEnvironment 컴포넌트`로 구성됨

- 생성 초기 :
- `LexicalEnvironment 컴포넌트와 `
- `VariableEnvironment 컴포넌트`는
- 하나의 `동일한 렉시컬 환경을 참조`

- `strict mode`, `eval`, `try/catch`문을 `제외`하고
- 구분하지 않고 같은 렉시컬 환경으로 간략하게 생각하여 설명

1. `환경 레코드(Environment Record)`

- 스코프에 포함된 `식별자를 등록`하고
- `등록된 식별자에 바인딩된 값을 관리하는 저장소`
- 환경 레코드 : 소스코드의 타입에 따라
- 관리하는 내용의 차이가 있음

2. `외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)`

- 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킴
- `상위 스코프` : `외부 렉시컬 환경`
- 실`행 컨텍스트를 생성한 소스코드를 포함`하는
- 상위 코드의 렉시컬 환경을 말함
- 외부 렉시컬 환경에 대한 참조를 통해
- `단방향 링크드 리스트인` → `스코프 체인을 구성`함

### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 다음 예제를 통해 실행 컨텍스트가 생성되고
- 코드 실행 결과가 관리되는지
- 어떻게 실행 컨텍스트를 통해 식별자를 검색하는지 학습

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}
foo(20); // 42
```

#### 23.6.1 전역 객체 생성

- `전역 객체` : 전역 코드가 `평가되기 이전에 생성`
- `전역 객체`에는 1. `빌트인 전역 프로퍼티`와
- 2. `전역함수`, 3. `표준 빌트인 객체가 추가`되어
- 동작환경에 따라 → 클라이언트 사이드, 호스트 객체를 포함

- 전역 객체도 Object.prototype을 상속받음

> 즉 : 전역 객체도 프로토타입 체인의 일원

```js
// Object.prototype.toString
window.toString(); // [object Window]

window.__proto__.__proto__.__proto__.__proto__ === Object.prototype;
```

#### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 `JS 엔진` : `전역 코드를 평가함`
- 전역 코드 평가는 다음과 같은 순서로 진행

1. 전역 실행 컨텍스트 생성

2. 전역 렉시컬 환경 생성
   - 2.1 전역 환경 레코드 생성
     - 2.1.1 객체 환경 레코드 생성
     - 2.1.2 선언적 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

##### 1. 전역 실행 컨텍스트 생성

- `먼저 비어있는 전역 실행 컨텍스트를 생성`하여
- `실행 컨텍스트 스택에 푸시`함
- 이때 전역 실행 컨텍스트 :
- 실행 컨텍스트 스택의 최상위 → 실행 중인 컨텍스트
- `(running execution context)`가 됨

##### 2. 전역 렉시컬 환경 생성

- 전역 렉시컬 환경을 생성하고
- 전역 실행 컨텍스트에 바인딩

> 23.5에서 보았듯 렉시컬 환경은 2개의 컴포넌트
>
> 1. 환경 레코드
> 2. 외부 렉시컬 환경에 대한 참조로 구성

###### 2.1 전역 환경 레코드 생성

- `전역 렉시컬 환경을 구성하는 컴포넌트`인
- `전역 환경 레코드(Global Environment Record)`는
- `전역 변수를 관리`하는
- 1. `전역 스코프`, 2. `전역 객체의 빌트인 전역 프로퍼티`,
- 3. `빌트인 전역 함수`, 4. `표준 빌트인 객체`를 제공

- 모든 전역 변수가 전역 객체의 프로퍼티가 되는 `ES6 이전`
- `전역 객체`가 → `전역 환경 레코드의 역할을 수행`
- 하지만 : `ES6 이후` `let`, `const` 키워드로 선언한 `전역 변수`
- 전역 객체의 프로퍼티가 되는 것이 아닌
- `개념적인 블록 내에 존재`하게 됨

- 이처럼 기존의 `var 키워드로 선언한 전역 변수`와
- `ES6`의 `let, const 키워드`로 선언한 `전역 변수를 구분하여 관리`하기 위해
- 전역 스코프 역할을 하는 전역 환경 레코드는
- 1. 객체 환경 레코드(Object Environment Record)
- 2. 선언적 환경 레코드(Declarative Environment Record)로 구성

- 객체 환경 레코드 : 기존의 전역 객체가 관리하던
- var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한
- 1. 전역 함수, 2. 블트인 전역 프로퍼티, 3. 빌트인 전역 함수
- 4. 표준 빌트인 객체를 관리

- `선언적 환경 레코드` : `let`, `const` `키워드로 선언한 전역 변수를 관리`
- 전역 환경 레코드의 객체 환경 레코드와 선언적 환경
- 서로 협력하여 전역 스코프, 전역 객체(전역 변수의 전역 객체 프로퍼티)
- 관리하게 됨

######## 객체 환경 레코드 생성

- `젼역 환경 레코드를 구성하는 컴포넌트`인
- 객체 환경 레코드 : `BindingObject`라고 부르는 객체와 연결됨
- `BindingObject` : 전역 객체 생성에서 생성된 전역 객체

- 전역 코드 평가 과정 : var 키워드로 선언한 전역 변수와,
- 함수 선언문으로 정의된 → 전역 함수
- 전역 환경 레코드의 객체 환경 레코드에 연결된
- BindingObject를 통해 전역 객체의 프로퍼티와, 메서드가 됨
- 이때 : 등록된 식별자를 전역 환경 레코드의 객체 환경 레코드에서
- 검색하면 전역 객체의 프로퍼티를 검색하여 반환

- 이것이 `var 키워드로 선언된` → `전역 변수`
- `함수 선언문으로 정의`된 → `전역 함수`가
- `전역 객체`의 `프로퍼티`와 `메서드`가 되고
- `전역 객체`를 → `가리키는 식별자(window) 없이`
- 전역 객체의 `프로퍼티를 참조`
- ex) window.alert을 alert 없이 참조
- 할 수 있게 되는 `메커니즘`

- 위 예제의 `전역 변수 x`, `전역 함수 : foo`
- `객체 환경 레코드`를 통해
- 객체 환경 레코드의 `BindingObject에 바인딩`되어 있는
- `전역 객체의 프로퍼티와 메서드`가 됨

```js
var x = 1;
const y = 2;

function foo(a) {}
```

- `x 변수` : `var 키워드`로 선언한 변수
- 1. `선언 단계`와, 2. `초기화 단계` 동시에 진행
- 1. `전역 코드 평가 시점` → `객체 환경 레코드에 바인딩`된
- `BindingObject`를 통해 `전역 객체에 변수 식별자 키` 등록
- 2. 암묵적으로 `undefined 바인딩`

- 딸라서 `var 키워드로 선언한 변수` : `코드 실행 단계`에서
- 변수 선언문 이전에도 참조가 가능
- 변수 선언문 이전에 참조한 변수의 값 :
- `언제나 undefined`임
- var 키워드로 선언한 변수에 할당한 `함수 표현식`도
- `동일하게 동작`

- 함수 선언문으로 정의한 함수가 평가 →
- 함수 이름과 동일한 이름의 식별자를
- 객체 환경 레코드에 바인딩된 BindingObject를 통해
- 전역 객체에 → 키를 등록 후 생성된 함수 객체를 즉시 할당
- 이것이 변수 호이스팅 <-> 함수 호이스팅의 차이

> 함수 선언문으로 정의 함수 : 함수 선언문 이전 호출 가능

######## 2.1.2 선언적 환경 레코드 생성

- var 키워드로 선언한 전역 변수와
- 함수 선언문으로 정의한 전역 함수 이외의 선언
- 즉 : `let`, `const`로 선언한 `전역 변수` :
- `선언적 환경 레코드`에 등록되고 관리

> 개념적 블록 : 전역 환경 레코드의 선언적 환경 레코드

- `let`, `const`의 경우 `전역 객체의 프로퍼티가 되지 않음`
- 당연하게 window로 접근 불가
- `const 선언` → `선언 단계`, `초기화 단계` `분리`되어 진행
- `초기화 단계` → `런타임에 실행 흐름이 변수 선언문에 도달하기 전`
- `일시적 사각지대(Temporal Dead Zone; TDZ)`

- y 변수에 바인딩 되어 있는 `<uninitialized>`는 초기화 단계에
- 진행되지 않아 → 변수에 접근 불가를 나타냄

- `let`, `const` 키워드 또한 변수 호이스팅이 발생하는 것은
- `변함이 없음`
- 단, let const 키워드 선언 변수 : `런타임`에 컨트롤이
- `변수 선언문에 도달하기 전`까지 `일시적인 사각지대`
- `참조가 불가`능하다.

```js
let foo = 1; // 전역 변수

{
	// let, const 키워드로 선언한 변수가
	// 호이스팅되지 않는다면 전역 변수를 참조해야함
	// 하지만 let 키워드로 선언한 변수도 여전히 호이스팅 발생
	// 참조 에러가 발생하게 됨
	console.log(foo); // ReferenceError
	let foo = 2; // 지역 변수
}
```

######## 2.2 this 바인딩

- 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에
- this가 바인딩됨
- 일반적으로 전역 코드 this → 전역 객체를 가리킴
- 전역 코드에서 this를 참조하면 전역 환경 레코드의
- `[[GlobalThisValue]]` `내부 슬롯에 바인딩`되어 있는
- `객체가 반환`됨

- `전역 환경 레코드를 구성`하는 :
- 1. `객체 환경 레코드`와
- 2. `선언적 환경 레코드`에는
- `this 바인딩이 없음`

- `this 바인딩` : 1. `전역 환경 레코드`와
- 2. `함수 환경 레코드`에만 존재

######## 2.3 외부 렉시컬 환경에 대한 참조 결정

- `외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)`
- `현재 평가 중인 소스코드를 포함`하는 `외부 소스코드의 렉시컬 환경`
- 즉 : `상위 스코프`를 가리킴
- 이를 통해 `단방향 링크드 리스트`인 : `스코프 체인을 구현`

- 현재 평가중인 소스코드 : `전역 코드`
- `전역 코드를 포함하는 소스코드는 없음`
- 전역 렉시컬 환경의` 외부 렉시컬 환경에 대한`
- `참조에 null이 할당`
- 전역 렉시컬 환경이 `스코프 체인의 종점에 존재`함 의미

#### 26.6.3 전역 코드 실행

- 이제 `전역 코드가 순차적으로 실행`되기 시작
- `변수 할당문 실행` → 전역 변수 x,y에 값이 할당
- 그리고 `foo 함수가 호출`

- 변수 할당문 또는 함수 호출문을 실행하려면
- 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인
- 선언되지 않은 식별자 : 참조 X → 참조나 호출도 불가

- 식별자 : 스코프가 다르면 같은 이름을 가질 수 잇음
- 동일한 이름의 식별자가 다른 스코프에 여거래 존재 가능
- 어느 스코프의 식별자를 참조하면 되는지 결정할 필요 있음
- 이를 : `식별자 결정(identifier resolution)`

- `식별자 결정을 위한 식별자를 검색` :
- 실행중인 `실행 컨텍스트에서 식별자를 검색`하기 시작함
- `선언된 식별자` : `실행 컨텍스트의 렉시컬 환경` →
- `환경 레코드에 등록`되어 있음

- `현재 실행 중인 실행 컨텍스트` : 전역 실행 컨텍스트
- `전역 렉시컬 환경`에서 `식별자` x, y,foo를 `검색 시작`
- 만약 실`행 중인 실행 컨텍스트의 렉시컬 환경`에서
- `식별자를 검색할 수 없는 경우`
- `외부 렉시컬 환경`에 대한 참조가 가리키는 →
- 렉시컬 환경, 즉 : `상위 스코프로 이동하여 식별자 검색`

> 이것이 스코프 체인의 동작 원리

- `전역 렉시컬 환경` : `스코프 체인의 종점`
- `전역 렉시컬 환경에서 검색할 수 없는 식별자`는
- 참조 에러(ReferenceError)를 발생
- 식별자 결정에 실패했기 때문

> 실행 컨텍스트 : 소스코드를 실행하기 위해 필요한 환경을 제공
> 코드의 실행 결과를 실제로 관리하는 영역

#### 23.6.4 foo 함수 코드 평가

- 예제 코드
- 현재 코드 평가를 통해 전역 실행 컨텍스트가 생성
- 전역 코드를 실행중
- 현재 진행 상황 : foo 함수 호출 전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}

foo(20); // 호출 직전
```

- `foo 함수가 호출`되면 : 전역 코드의 실행을 `일시 중단`
- `foo 함수 내부`로 코드의 `제어권이 이동`
- 함수 코드를 `평가하기 시작`
- 함수 코드 평가는 다음과 같은 `순서`로 진행

1. 함수 실행 컨텍스트 생성

2. 함수 렉시컬 환경 생성
   - 2.1 함수 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

##### 1. 함수 실행 컨텍스트 생성

- 먼저 foo 함수 `실행 컨텍스트를 생성`
- `생성된 컨텍스트` : 함수 렉시컬 환경이 완성된 다음
- `실행 컨텍스트 스택에 푸시`
- 이때 foo 함수 실행 컨텍스트 : 실행 컨텍스트 스태의
- 최상위 → `실행 중인 실행 컨텍스트(running execution context)`

##### 2. 함수 렉시컬 환경 생성

- foo 함수 `렉시컬 환경(Function Lexical Environment)`을 `생성`하고
- foo 함수 `실행 컨텍스트에 바인딩`

- 렉시컬 환경 : 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구성

###### 2.1 함수 환경 레코드 생성

- 함수 렉시컬 환경 구성의 함수 환경 레코드 :
- 1. `매개변수`, 2. `arguments 객체`, 3. `함수 내부에서 선언한 지역 변수`
- 4. `중첩 함수를 등록하고 관리`하게됨

###### 2.2 this 바인딩

- 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 this 바인딩
- `[[ThisValue]] 내부 슬롯에 바인딩될 객체`는
- 함수 호출 방식에 따라 결정됨

- foo 함수 : 일반 함수로 호출되었으므로 this : 전역 객체를 가리킴
- 함수 환경 레코드 `[[ThisValue]]` 내부 슬롯 → `전역 객체 바인딩`
- foo 함수 내부에서 this를 참조하면 함수 환경 `[[ThisValue]]`
- `내부 슬롯에 바인딩되어 있는 객체가 반환`

###### 2.3 외부 렉시컬 환경에 대한 참조 결정

- `외부 렉시컬 환경`에 대한 참조에 `foo 함수 정의가 평가된 시점`
- 실행 중인 `실행 컨텍스트의 렉시컬 환경`의 참조가 할당
- `foo 함수` : `전역 코드에 정의`된 `전역 함수`
- foo 함수 `정의` : `전역 코드 평가 시점`에 `평가`
- 이 시점의 `실행 중인 실행 컨텍스트` : `전역 실행 컨텍스트`
- `외부 렉시컬 환경`에 대한 `참조` → `전역 렉시컬 환경의 참조`가 할당

- 렉시컬 스코프에서 JS : 함수를 어디서 호출했는지 x
- 어디에 정의했는지에 따라 상위 스코프를 결정
- 또한 함수 객체 → 자신이 정의된 스코프
- 즉 : 상위 스코프를 기억함

- JS 엔진 : `함수 정의를 평가`하여
- `함수 객체를 생성`할 때 `현재 실행중인 실행 컨텍스트`의
- `렉시컬 환경` → 즉 : `상위 스코프를 함수 객체의 내부 슬롯`
- `[[Environment]]`에 저장하게 됨
- 함수 `렉시컬 환경의 외부 렉시컬 환경`에 대한 `참조에 할당`
- 함수의 `상위 스코프를 가리키는` `함수 객체의 내부 슬롯`
- `[[Environment]]`에 저장된 렉시컬 환경의 참조

> 즉 : 함수 객체의 내부 슬롯 [[Environment]] :
> 렉시컬 스코프를 구현하는 매커니즘
> 이는 클로저를 이해하는 중요한 단서

#### 23.6.5 foo 함수 코드 실행

- 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행
- 1. 매개변수에 인수가 할당되고, 2. 변수 할당문이 실행 →
- 지역 변수에 값이 할당
- 3. 함수 호출

- 이때 `식별자 결정을 위해` 실행 중인 `실행 컨텍스트`의
- `렉시컬 환경`에서 `식별자를 검색`하기 시작
- 현재 `실행 중인 실행 컨텍스트` : foo 함수 실행 컨텍스트
- foo 함수 `렉시컬 환경`에서 식별자 x,y를 검색하기 시작

- 만약 실행 컨텍스트에서 찾을 수 없으면
- `외부 렉시컬 환경에 대한 참조`가 가리키는
- `렉시컬 환경으로 이동`하여 `식별자를 검색`
- 검색된 식별자에 `값을 바인딩`

#### 26.6.6 bar 함수 코드 평가

- 현재 foo 함수 코드 평가를 통해 → foo 함수 실행 컨텍스트 생성
- foo 함수 코드를 실행하고 있음
- 현재 : bar 함수를 호출하기 직전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10); // 호출 직전
}
foo(20);
```

- `bar 함수가 호출`되면 → `bar 함수 내부`로 `코드의 제어권이 이동`
- `bar 함수 코드를 평가하기 시작`함
- `실행 컨텍스트`와 `렉시컬 환경의 생성 과정` :
- `foo 함수 코드 평가와 동일`

#### 23.6.7 bar 함수 코드 실행

- 런타임 시작 → bar 함수의 소스코드가 순차적으로 실행
- 1. `매개변수` : `인수 할당`
- 2. `변수 할당문`이 실행 : `지역 변수` z에 `값이 할당`
- 3. `console.log(a + b + x + y + z);` 가 실행

> 코드의 실행 순서

##### 1. console 식별자 검색

- 먼저 console 식별자 → `스코프 체인`에서 검색
- `스코프 체인` : `현재 실행 중`인 실행 컨텍스트의
- `렉시컬 환경`에서 `시작`하여 `외부 렉시컬 환경에 대한 참조`로
- 이어지게되는 `렉시컬 환경의 연속`
- 식별자를 검색 : `언제나 실행 중인` `실행 컨텍스트의 렉시컬 환경` 검색

- 실행 중 실행 컨텍스트 : `bar 함수 실행 컨텍스트`
- 따라서 : bar 함수 실행 컨텍스트의
- bar 함수 렉시컬 환경에서 console 식별자 검색 → 하지만 없음
- 고로 `상위 스코프` → 즉 : `외부 렉시컬 환경에 대한 참조`가 가리키는
- `foo 함수 렉시컬 환경`에서 검색

- 이곳에도 없기 때문에 `전역 렉시컬 환경으로 이동`하여 식별자 검색

> 전역 렉시컬 환경

    객체 환경 레코드, 선언적 환경 레코드
 console 식별자 : 객체 환경 레코드
 BindingObject를 통해 전역 객체에서
 찾을 수 있게 됨

##### log 메서드 검색

- `console 식별자에 바인딩`된 객체
- 즉 : console 객체에서 `log 메서드를 검색`
- `console 객체`의 `프로토타입 체인`을 통해
- `메서드를 검색`
- `log 메서드` : `상속된 프로퍼티가 아닌`
- console 객체가 `직접 소유하는 프로퍼티`

```js
console.hasOwnProperty('log'); // true
```

##### 표현식 a + b + x + y + z 의 평가

- 이제 `식별자를 검색`하게 됨
- `식별자` : `스코프 체인`
- 즉 : `현재 실행 중인 실행 컨텍스트`의
- `렉시컬 환경에서 시작`하여 → `외부 렉시컬 환경에 대한 참조`
- `렉시컬 환경의 연속`에서 검색

- a : foo 함수 렉시컬 환경
- b : bar 함수 렉시컬 환경

##### console.log 메서드 호출

- `표현식`이 `평가`되어 생성한 값 42를
- `console.log 메서드`에 `전달`하여 `호출`

#### 23.6.8 bar 함수 코드 실행 종료

- `console.log 메서드가 호출되고 종료`하면
- 더는 `실행할 코드가 없으므로 bar 함수 코드의 실행이 종료`
- 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거
- foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 됨

- `실행 컨텍스트 스택`에서 `bar 함수 실행 컨텍스트가 제거` 되었다고 해서
- `bar 함수 렉시컬 환경`까지 `즉시 소멸하는 것은 아님`
- `렉시컬 환경`은 `실행 컨텍스트에 의해 참조`되기는 하지만 `독립적인 객체`
- `객체를 포함한 모든 값` : 누군가에 의해 참조되지 않았을 때
- 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸

> bar 함수 실행 컨텍스트가 소멸되었다 하더라도
> bar 함수 렉시컬 환경을 누군가 참조하고 있다면
> bar 함수 렉시컬 환경은 소멸하지 않음

#### 23.6.9 foo 함수 코드 실행 종료

- `bar 함수가 종료`하면 더 이상 실행할 코드가 없으므로
- `foo 함수 코드의 실행이 종료`됨
- 이때 `실행 컨텍스트 스택`에서 foo 함수 `실행 컨텍스트가 팝되어 제거`
- `실행 컨텍스트가` `실행 중인 실행 컨텍스트가 됨`

#### 23.6.10 전역 코드 실행 종료

- `foo 함수가 종료`되면 더는 `실행할 전역 코드가 없으므로`
- `전역 코드의 실행이 종료`되고 `전역 실행 컨텍스트`도
- 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는
- 아무것도 남아있지 않게됨

### 23.7 실행 컨텍스트와 블록 레벨 스코프

- `var 키워드로 선언한 변수` : 오로지 `함수의 코드 블록만`
- 지역 스코프로 인정하는 `함수 레벨 스코프`를 따름
- 하지만 `let`, `const`로 선언한 변수 : `모든 코드 블록`
- (`함수`, `if`, `for`, `while`, `try/catch`)을 `지역 스코프로 인정`하는
- `블록 레벨 스코프`를 따름

```js
let x = 1;

if (true) {
	let x = 10;
	console.log(x); // 10
}

console.log(x); // 1
```

- `if 문의 코드 블록 내`에서
- `let 키워드로 변수`가 선언
- 따라서 : `if 문의 코드 블럭이 실행` →
- if 문의 코드 블록을 위한 `블록 레벨 스코프`를 생성
- 이를 위해 `선언적 환경 레코드를 갖는 렉시컬 환경`
- 새롭게 생성하여 `기존의 전역 렉시컬 환경을 교체`
- 새롭게 생성한 if 문의 코드 블록을 위한 렉시컬 환경의
- 외부 렉시컬 환경에 대한 참조는 `if문이 실행되기 이전의 전역`
- `렉시컬 환경`을 가리키게됨

> if 문 코드 블록의 실행이 종료되면 if 문의 코드 블록이 실행되기
> 이전의 렉시컬 환경으로 되돌림

- 이는 if 문 뿐만 아닌 블록 레벨 스코프를 생성하는 모든 블록문 적용

- `for문의 변수 선언문`에 `let 키워드를 사용`한
- `for 문은 코드 블록이 반복해서 실행`될 때마다
- 코드 블록을 위한 `새로운 렉시컬 환경을 생성`
- 만약 `for문의 코드 블록 내에서 정의된 함수`가 있다면
- 이 `함수의 상위 스코프` → `for 문의 코드 블록`이 생성한 `렉시컬 환경`임

- 이때 `함수의 상위 스코프` : `for 문의 코드 블록이 반복`해서 `실행`
- 할 때마다 `식별자`(for 문의 변수 선언문 및 for 문의 코드 블록 내에서)
- 선언된 지역 변수)등의 `값을 유지`해야 함
- 이를 위해 `for 문의 코드 블록이 반복`해서 `실행`될 때마다
- `독립적인 렉시컬 환경을 생성`하여 `식별자의 값을 유지`

---

## 24. 클로저

- `클로저(closure)` : 난해하기로 유명한 JS 개념 중 하나
- 실행 컨텍스트에 대한 개념이 없다면 이해하기 어려움

- JS의 고유 개념은 아니고 함수를 일급 객체로 취급하는
- 함수형 프로그래밍 언어에서 사용되는 중요한 특성
- 고유 개념이 아니므로 ECMAScript 사양에 등장하지 않음

- MDN 정의 :
- `클로저`는 `함수와 그 함수가 선언한 렉시컬 환경과의 조합`

> 핵심 키워드 : 함수가 선언된 렉시컬 환경

```js
const x = 1;

function outerFunc() {
	const x = 10;
	function innerFunc() {
		console.log(x); // 10
	}

	innerFunc();
}

outerFunc();
```

- outerFunc 함수 내부 : `중첩 함수 innerFunc가 정의되고 호출`
- 중첩 함수 innerFunc의 상위 스코프 → 외부 함수 outerFunc 스코프
- 중첩 함수 `innerFunc 내부에서 자신을 포함하고 있는 외부 함수`
- `x에 접근`이 가능함

- 만약 중첩 함수가 아니라면 innerFunc 함수를
- outerFunc 함수의 내부에서 호출한다 하더라도 outerFunc 함수의 변수에
- 접근이 불가능함

```js
const x = 1;

function outerFunc() {
	const x = 10;
	innerFunc();
}

function innerFunc() {
	console.log(x); // 1
}

outerFunc();
```

> 위와 같은 이유 : JS가 렉시컬 스코르를 따르는 프로그래밍 언어

### 24.1 렉시컬 스코프

- JS엔진 : 함수를 어디서 호출이 아닌 → 함수를 어디에 정의했는지에 따라
- 상위 스코프를 결정하게 됨
- 이를 렉시컬 스코프(정적 스코프)라고 하게 됨

```js
const x = 1;

function foo() {
	const x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // ?
bar(); // ?
```

- foo, bar 함수는 모두 전역에서 정의된 전역 함수
- 함수의 상위 스코프 : 함수를 어디서 정의 했느냐에 따라 달라지므로
- foo 함수와 bar 함수의 상위 스코프 : 전역
- 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 못줌

- 즉 : `함수의 상위 스코프` : 함수를 `정의한 위치`에 의해 `정적으로 결정`되고
- `변하지 않음`

- 스코프의 실체 : 실행 컨텍스트의 렉시컬 환경
- 렉시컬 환경 : 자신의 외부 렉시컬 환경에 대한 참조에 저장할 참조값이
- 바로 상위 렉시컬 환경에 대한 참조 → 이것이 상위 스코프

- 렉시컬 환경의 `외부 렉시컬 환경에 대한 참조에 저장할 참조값`
- 즉 : `상위 스코프에 대한 참조` : `함수 정의가 평가되는 시점`에
- 함수가 정의된 환경에 의해 결정됨
- 이것을 `렉시컬 스코프라고 부름!`

### 24.2 함수 객체의 내부 슬롯 [[Environment]]

- 함수가 정의된 환경(위치), 호출되는 환경(위치)은 다를 수 있음
- 렉시컬 스코프가 가능하기 위해서는 함수 → 자신이 호출되는 환경과 무관하게
- 상관없이 자신이 정의된 환경, 즉 : 상위 스코프(함수 정의가 위치하는 스코프가
- 바로 상위 스코프다)라는 것을 기억해야 함

- 함수 : 자신의 `내부 슬롯 [[Environment]]`에 자신이 정의된 환경
- → `상위 스코프의 참조를 저장`하게 됨

- 함수 정의가 평가되어 `함수 객체를 생성` :
- 자신이 정의된 환경(위치)에 의해 결정된 `상위 스코프의 참조`를
- 함수 객체 자신의 `내부 슬롯 [[Environment]]에 저장`
- 자신의 내부 슬롯 [[Environment]]에 저장된 상위 스코프의 참조 :
- 현재 실행 중인 실행 `컨텍스트의 렉시컬 환경`을 가리킴

- 함수 정의가 평가되어 함수 객체 생성 시점 :
- 함수가 정의된 환경 → `1. 상위 함수(또는 전역 코드)가 평가` 또는
- 2. `실행되고 있는 시점`
- 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킴
- 실행 컨텍스트 : 상위 함수(또는 전역 코드)의 실행 컨텍스트이기 때문

- ex ) `전역에서 정의된 함수 선언문` : `전역 코드가 평가되는 시점`에
- `평가되어 함수 객체를 생성`함
- 생성된 함수 객체의 내부 슬롯 [[Environment]]에는 함수 정의가 평가되는 시점
- 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 `렉시컬 환경인 전역`
- 렉시컬 환경의 참조가 저장됨
- 따라서 : `함수 객체의 내부 슬롯 [[Environment]]에 저장`된
- 현재 실행 중인 → `실행 컨텍스트의 렉시컬 환경의 참조` : 상위 스코프
- 또는 : `자신이 호출되었을 때 생성될 렉시컬 환경`의 →
- 외부 렉시컬 환경에 대한 참조에 저장될 참조값
- 함수 객체 : 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조
- 즉 → 상위 스코프를 자신이 존재하는 한 기억

```js
const x = 1;

function foo() {
	const x = 10;

	// 상위 스코프 : 함수 정의 환경(위치)에 따라 결정됨
	// 함수 호출 위치와 상위 스코프 : 아무런 관계 없음
	bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 : 렉시컬 환경을
// [[Environment]]에 저장하여 기억하게 됨
function bar() {
	console.log(x);
}

foo();
bar();
```

- foo 함수, bar 함수 : 모두 `전역에서 함수 선언문`으로 정의
- 따라서 : foo 함수, bar 함수는 모두 `전역 코드가 평가되는 시점`에 평가
- `함수 객체를 생성` → `전역 객체 window의 메서드`가 됨

- 이때 생성된 함수 객체의 내부 슬롯 : [[Environment]]에는
- 함수 정의가 평가된 시점, 즉 → `전역 코드 평가 시점`에 `실행 중인`
- `실행 컨텍스트의 렉시컬 환경`인 `전역 렉시컬 환경의 참조가 저장`

- 함수 호출 : 함수 내부 코드로 코드의 제어권이 이동
- 함수 코드를 평가하기 시작
- 코드 평가의 순서

1. `함수 실행 컨텍스트` 생성
2. `함수 렉시컬 환경` 생성
   - 2.1 `함수 환경 레코드` 생성
   - 2.2 `this` 바인딩
   - 2.3 외부 `렉시컬 환경에 대한 참조 결정`

- `외부 렉시컬 환경에 대한 참조` : `함수 객체의 내부 슬롯`
- [[Environment]]에 `저장된 렉시컬 환경의 참조가 할당`
- 즉 : 함수 객체의 내부 슬롯 [[Environment]]에 저장된 `렉시컬 환경의 참조` :
- `함수의 상위 스코프를 의미`

> 함수 결정의 위치에 따라 상위 스코프를 결저앟는
> 렉시컬 스코프의 실체

### 24.3 클로저와 렉시컬 환경

```js
const x = 1;

// 1
function outer() {
	const x = 10;
	const inner = function () {
		console.log(x);
	}; // 2
	return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환
// 그리고 outer 함수의 실행 컨텍스트 : 실행 컨텍스트 스택에서
// 팝되어 제거됨
const innerFunc = outer(); // 3
innerFunc(); // 4
```

- outer 함수를 호출(3)하면 → outer 함수는 중첩 함수 inner를 반환하고
- `생명 주기(life cycle)를 마감`
- outer 함수의 실행이 종료되면 → outer 함수의 실행 컨텍스트 :
- `실행 컨텍스트 스택에서 제거`되게 됨
- outer 함수의 실행 컨텍스트 제거 →
- outer 함수의 지역 변수 x 또한 `생명 주기를 마감`
- outer 함수의 지역 변수 x `더이상 유효하지 않게 보임`

> 하지만 4번에서 보면 잘 동작함

- `외부 함수보다 중첩 함수가 더 오래 유지`되는 경우 :
- 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조 가능
- 이를 `클로저(closure)`라고 부름

- `클로저` : `함수`와 그 `함수가 선언된 렉시컬 환경`과의 조합
- 함수가 정의된 `렉시컬 환경` → `함수가 정의된 위치의 스코프`
- 즉 : 상위 스코프를 의미하는 실행 컨텍스트의 렉시컬 환경을 말함

- JS의 모든 함수 : `자신의 상위 스코프를 기억`함
- 모든 함수가 기억하는 상위 스코프 : `함수를 어디서 호출하든 상관없이 유지`
- 함수를 어디서 호출하든 상관없이 함수 → 언제나 자신이 기억하는
- 1. `식별자를 참조`할 수 있으며 2. `식별자에 바인딩된 값을 변경`할 수 있음

- inner 함수 : 자신이 평가될 때 자신이 정의된 위치에 의해 결정된
- 상위 스코프 → [[Environment]] 내부 슬롯에 저장함
- 이때 저장된 상위 스코프 : 함수가 존재하는 한 유지

- ex ) outer 함수가 평가되어 → 함수 객체를 생성할 때 - 1
- 현재 실행 중인 실행 컨텍스트의 렉시컬 환경
- 즉 : 전역 렉시컬 환경 → outer 함수 객체의 [[Environment]] 내부 슬롯에
- 상위 스코프로서 저장하게 됨

- outer 함수를 호출 → outer 함수의 렉시컬 환경이 생성되고 앞서
- 함수 객체의 [[Environment]] 내부 슬롯에 저장된 전역 렉시컬 환경
- outer 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 할당

- 그리고 중첩 함수가 평가 → inner의 경우 함수 표현식으로 정의 :
- 런타임에 평가가 이루어지게 됨
- 이때 : 중첩 함수 inner : 자신의 [[Environment]] 내부 슬롯에
- 현재 실행 중인 실행 컨텍스트 렉시컬 환경
- 즉 : outer 함수의 렉시컬 환경을 상위 스코프로서 저장

- outer 함수의 실행이 종료 : `inner 함수를 반환`
- outer 함수의 생명 주기가 종료
- outer 함수의 실행 컨텍스트 : `실행 컨테스트 스택에서 제거`되지만
- `outer 함수의 렉시컬 환경까지 소멸되는 것은 아님`

- outer 환경의 렉시컬 환경 :
- 1. inner 함수의 [[Environment]] 내부 슬롯에 의해 참조,
- 2. 전역 변수 innerFunc에 의해 참조되고 있음
- → 고로 가비지 컬렉션의 대상이 되지 않음
- `가비지 컬렉터는 누군가가 참조하고 있는 메모리 공간 해제 X`

> 가비지 컬렉터 : 누군가 참조 → 메모리 공간 해제 X

- outer 함수가 반환한 inner 함수를 호출하면 :
- 1. inner 함수의 실행 컨텍스트가 생성
- 2. 실행 컨텍스트 스택에 푸시됨
- 3. 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는
- inner 함수 객체의 [[Environment]] 내부 슬롯에 저장되어 잇는
- 참조값이 할당됨

- 중첩 함수 inner : 외부 함수 outer보다 더 오래 생존
- 외부 함수보다 더 오래 생존한 중첩 함수 :
- `외부 함수의 생존 여부(실행 컨텍스트의 생존)와 관계없이`
- 자신이 `정의된 위치에 의해` `결정된 상위 스코프를 기억`함
- `중첩 함수` inner `내부`에서 `상위 스코프를 참조`할 수 있으므로
- `상위 스코프의 식별자를 참조`할 수 있고
- `식별자의 값을 변경` 가능

- JS의 모든 함수 : 상위 스코프를 기억하게 되므로
- 이론적으로 모두 클로저이다!
- 하지만 모든 함수를 클로저라고 부르지는 않는다.

> 상위 스코프의 어떤 식별자도 참조하지 않는 함수는
> 클로저가 아님!

- `상위 스코프의 어떤 식별자도 참조하지 않는 경우` :
- 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억 안함
- `참조하지도 않는 식별자를 기억하는 것은 낭비`

```js
function foo() {
	const x = 1;

	// bar 함수는 클로저였지만 곧바로 소멸
	// 이러한 함수 일반적으로 클로저라고 하지 않음
	function bar() {
		debugger;
		// 상위 스코프의 식별자를 참조
		console.log(x);
	}
	bar();
}
foo();
```

- 위 예제의 중첩 함수 bar : 상위 스코프의 식별자를 참조
- 즉 : 클로저의 목적에 부함
- 그러나 → 외부 함수 foo의 외부로 중첩 함수가 bar가 `반환되지 않음`
- 즉 : `외부 함수 foo보다 중첩 함수 bar 생명 주기가 짧음`
- 이런 경우 중첩 함수 bar : 클로저였지만 외부 함수보다 일찍 소멸됨
- 그렇기에 `[생명 주기가 종료된 외부 함수의 식별자를 참조 가능함]`의
- `클로저의 본질에 부합하지 않음`

```js
function foo() {
	const x = 1;
	const y = 2;

	// 클로저
	// 중첩 함수 bar : 외부 함수보다 더 오래 유지되며
	// 상위 스코프의 식별자를 참조
	function bar() {
		debugger;
		console.log(x);
	}
	return bar;
}

const bar = foo();
bar();
```

- 중첩 함수 bar : 상위 스코프의 식별자를 참조하고 있음
- 고로 클로저임
- 또한 : 외부 함수의 외부로 반환 → 외부 함수보다 오래 살아남음

- 이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우
- 중첩 함수 : 이미 생명 주기가 종료된 외부 함수의 변수를 참조 가능
- 이러한 중첩 함수 : 클로저라고 부름

- 클로저 : 1. `중첩 함수가 상위 스코프의 식별자를 참조`하고 있고
- 2. `중첩 함수가 외부 함수보다 더 오래 유지되는 경우`에 한정하는 것이 일반적

> 위 예제 처럼 상위 스코프 식별자 중 하나만 참조하게 될 경우
> 최적화를 위해서 클로저가 참조하고 있는 식별자만 기억하게 됨

- 클로저에 의해 참조되는 상위 스코프의 변수 (위에서 x)를
- `자유 변수(free variable)`이라고 부름
- `클로저(closure)` : 함수가 자유변수에 대해 닫혀 있다는 의미
- 해석 : 자유 변수에 묶여있는 함수

- 이론적으로 상위 스코프를 기억한다는 점이 불필요한 메모리의 점유를 걱정 가능
- 하지만 필요한 것만 JS엔진이 알아서 기억하기 때문에 걱정 X

### 24.4 클로저의 활용

- 클로저 : 1. `상태(state)를 안전하게 변경`하고
- 2. `유지하기 위해서 사용`
- 고로 상태가 의도치 않게 변경되지 않도록
- `상태를 안전하게 은닉(information hiding`)하고
- `특정 함수에게만 상태 변경을 허용` 위해 사용

> 함수가 호출될 때마다 호출된 횟수를 누적하여 출력하는 카운터

```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
	// 카운트 상태를 1만크 ㅁ증가
	return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 코드는 잘 동작하지만 문제가 생길 여지가 있음

1. 카운트 상태(num 변수의 값)는 increase 함수가 호출되기 전까지

   - 변경되지 않고 유지되어야 함

2. 이를 위해 카운트 상태(num 변수의 값)는 increase 함수만이
   - 변경할 수 있어야 함

- 카운트 상태 : 전역 변수를 통해 관리되고 있기 때문에
- 언제든지 누구나 접근할 수 잇고 변경할수 있음(암묵적 결합)
- 이로 인해서 의도치 않게 상태가 변경될 수 있음

- 이를 안전하게 이용하기 위해서는
- increase 함수만이 num 변수를 참조하고 변경 할 수 있게 하는 것이 바람직

```js
// 카운트 상태 변경 함수
const increase = function () {
	// 카운트 상태 변수
	let num = 0;

	// 카운트 상태를 1만큼 증가
	return ++num;
};
```

> 하지만 위의 경우 상태 변경은 방지 했지만
> 지역 변수로 동작하여서 원하는 대로 동작하지 않음

> 고로 클로저를 사용

```js
// 카운트 상태 변경 함수
const increase = (function () {
	// 카운트 상태 변수
	let num = 0;

	// 클로저
	return function () {
		// 카운트 상태를 1만큼 증가시킴
		return ++num;
	};
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 위 코드를 실행 하게 되면
- 1. `즉시 실행 함수가 호출`되고
- 2. `즉시 실행 함수가 반환한 함수가 increase 변수에 할당`
- increase 변수에 할당된 함수 : `자신이 정의된 위치`에 의해
- 결정된 상위 스코프인 → `실행 함수의 렉시컬 환경을 기억하는 클로저`

- `즉시 실행 함수` : `호출된 이후 소멸`
- 실행 함수가 반환한 클로저 : increase 변수에 할당되어 호출
- 이때 즉시 실행 함수가 반환된 클로저 : `자신이 정의된 위치`에 의해
- 결정된 `상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억`
- 즉시 실행 함수가 반환한 클로저 : 카운터 상태를 유지하기 위해서
- `자유 변수` num을 언제 어디서든지 `호출, 참조, 변경 가능`

- 즉시 실행 함수는 한 번만 실행되기 때문에
- increase가 호출될 때마다 num 변수가
- `재차 초기화 되는일은 없음`
- 또한 : num 변수는 `외부에서 직접 접근할 수 없는`
- `은닉화된 private 변수`이므로
- 전역 변수를 사용했을 때와
- 같이 `의도되지 않은 변경을 걱정할 필요가 없기 때문에`
- 더욱더 안전한 프로그래밍이 가능하다.

> 클로저 : 상태가 의도적으로 변경되지 않도록 은닉(information hiding)
> 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고
> 유지하기 위해 사용됨

```js
const counter = (function () {
	// 카운트 상태 변수
	let num = 0;

	// 클로저인 메서드를 갖는 객체를 반환
	// 객체 리터럴은 스코프를 만들지 않음
	// 따라서 안래 메서드들의 상위 스코프 :
	// 즉시 실행 함수의 렉시컬 환경임
	return {
		// num: 0 // 프로퍼티는 public 하므로 은닉 X
		increase() {
			return ++num;
		},
		decrease() {
			return num > 0 ? --num : 0;
		},
	};
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```

- 위 예제 : 즉시 실행 함수가 반환하는 `객체 리터럴` :
- `즉시 실행 함수의 실행 단계에서 평가되어 객체가 됨`
- 객체의 메서드도 함수 객체로 생성됨
- `객체 리터럴의 중괄호` → `코드 블록이 아니므로`
- 별도의 스코프를 생성하지 않음

- 위 예제의 `increase, decrease 메서드의 상위 스코프` :
- increase, decrease `메서드가 평가되는 시점`에
- `실행중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트`의
- `렉시컬 환경`임

- 따라서 → increase, decrease `메서드가 언제 어디서 호출`되는
- 상관없이 increase, decrease 함수는 `즉시 실행 함수의 스코프의 식별자`를
- `참조가 가능`함

```js
const Counter = (function () {
	// 1 카운트 상태 변수
	let num = 0;

	function Counter() {
		// this.name = 0; // 2. 프로퍼티는 public 하므로 은닉 X
	}

	Counter.prototype.increase = function () {
		return ++num;
	};

	Counter.prototype.decrease = function () {
		return num > 0 ? --num : 0;
	};

	return Counter;
})();

const counter = new Counter();
```

- 위 예제 num(1)은 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티가 아니라
- 즉시 실행 함수 내에서 선언된 벼수
- 만약 : num이 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티라면
- public → 은닉 변수가 아니게 됨
- 고로 즉시 실행 함수내에 변수를 선언하여 사용

- 생성자 함수 Counter : 프로토타입을 통해 `increase, decrease 메서드를 상속`
- 받는 인스턴스를 생성하게 됨
- 모두 자신의 함수 정의가 평가되어 → `함수 객체가 될 때`
- 실행 중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의
- `렉시컬 환경을 기억하는 클로저`임
- 프로토타입을 통해 `상속되는 프로토타입 메서드일지라도`
- 즉시 실행 함수의 `자유 변수 num을 참조가 가능함`
- num 변수의 값은 increase, decrease 메서드 만이 변경이 가능함

- 변수 값이 의도치 않게 변경되는 것은 `가변(mutable)` 데이터를 피하고
- `불변성(immutability)`을 지향하는 함수형 프로그래밍에서 부수 효과를
- 최대한 억제하여 오류를 피하고
- 프로그램의 안전성을 높이기 위해 클로저는 적극적으로 사용됨

```js
// 함수를 인수로 전달받고 함수를 반환하는 고차 함수
// 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환
function makeCounter(predicate) {
	// 카운트 상태를 유지하기 위한 자유 변수
	let counter = 0;

	// 클로저를 반환
	return function () {
		// 인수로 전달받은 보조 함수에 상태 변경을 위임
		counter = predicate(counter);
		return counter;
	};
}

// 보조 함수
function increase(n) {
	return ++n;
}

// 보조 함수
function decrease(n) {
	return --n;
}

// 함수로 함수를 생성
// makeCounter 함수 : 보조 함수를 인수로 전달받아 함수를 반환
const increaser = makeCounter(increase); // 1
console.log(increaser()); // 1
console.log(increaser()); // 2

// increaser 함수완느 별개의 독립된 렉시컬 환경을 갖기 때문에
// 카운터 상태가 연됭하지 않음
const decreaser = makeCounter(decrease); // 2
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

- makeCounter 함수 : 1. 보조 함수를 인자로 전달받고
- 2. `함수를 반환하는 고차 함수`임
- makeCounter 함수가 반환하는 함수 :
- 자신이 `생성됐을 때의 렉시컬 환경`인 `makeCounter 함수의 스코프에 속한`
- `counter 변수를 기억하는 클로저`임

- makeCounter 함수 : 인자로 전달받은 보조 함수를 합성하여
- `자신이 반환하는 함수의 동작을 변경이 가능`하다.
- makeCounter `함수를 호출해 함수를 반환할 때 반환된 함수` :
- `자신만의 독립된 렉시컬 환경을 갖는다는 것`
- 이는 : `함수를 호출하면 그때마다 새로운 makeCounter 함수 실행 컨텍스트`의
- `렉시컬 환경이 생성`되기 때문임

- makeCounter 함수를 호출하면 makeCounter 함수의 `실행 컨텍스트가 생성`
- makeCounter 함수 : `함수 객체를 생성하여 반환`한 후 `소멸`
- makeCounter 함수가 반환한 함수 : makeCounter 함수의 `렉시컬 환경`을
- `상위 스코프로서 기억하는 클로저`이며, `전역 변수`인 increaser에 할당
- 이때 makeCounter `함수의 실행 컨텍스트는 소멸`되지만
- makeCounter 함수 `실행 컨텍스트의 렉시컬 환경` :
- makeCounter 함수가 반환한 함수의 [[Environment]] 내부 슬롯에 의해
- 참조되고 있기 때문에 소멸되지 않음

- makeCounter 함수를 호출하면 → 새로운 makeCounter `함수의 실행 컨텍스트 생성`
- 그리고 : `함수 객체를 생성하여 반환하고 소멸`
- 반환한 함수 → makeCounter 함수의 `렉시컬 환경을 상위 스코프로 기억하는 클로저`
- `전역 변`수 decrease에 할당
- 이또한 반환 함수의 [[Environment]] `내부 슬롯에 참조 → 소멸 X`

> 고로 다른 렉시컬 환경을 가지기 때문에
> 자유 변수 counter를 공유하지 않아서
> 원하는대로 동작 하지 않음
> → 렉시컬 환경을 공유하는 클로저 생성

```js
// 함수를 반환하는 고차 함수
// 이 함수느 : 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는
// 클로저를 반환하게됨
const counter = (function() {
    // 카운트 상태를 유지하기 위한 자유 변수
    let counter = 0;

    // 함수를 인수로 전달받는 클로저를 반환
    return function (predicate) {
        // 인수로 전달받은 보조 함수에 상태 변경을 위임
        counter predicate(counter);
        return counter;
    }
}());

// 보조 함수
function increase(n) {
    return ++n;
}

// 보조 함수
function decrease(n) {
    return --n;
}

// 보조 함수를 전달하여 호출
console.log(counter(increase)); // 1
console.log(counter(increase)); // 2

// 자유 변수를 공유
console.log(counter(decrease)); // 1
console.log(counter(decrease)); // 0
```

### 24.5 캡슐화와 정보 은닉

- `캡슐화(encapsulation)` : 객체의 상태를 나타내는
- 1. 프로퍼티와, 2. 메서드(프로퍼티를 참조하고 조작 가능한 동작)
- 하나로 묶는 것을 뜻함

> 캡슐화 : 객체의 프로퍼티나 메서드 감출 목적으로 사용
> 이를 은닉(information hiding)이라고 함

- `정보 은닉` : 외부에 공개할 필요가 없는 것들을 감추어
- 1. `객체의 상태 변경 방지`
- 2. `객체 간의 상호 의존성`
- 3. `결합도(coupling)를 낮추`는 효과가 있음

- 대부분의 객체지향 프로그래밍 언어 : 클래스를 정의
- `public`, `private`, `protected` 등의 `접근 제한자를 사용`해서
- 공개 범위를 한정이 가능함

> 메서드를 프로토타입 메서드로 변경하여 sayHi 메서드의 중복 생성을 방지

```js
function Person(name, age) {
	this.name = name; // public
	let _age = age; // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
	// Person 생성자 함수의 지역 변수 _age
	// 참조가 불가능하다.
	console.log(`Hi! My name is ${this.name}. I am ${_age}`);
};
```

- 이때 Person.prototype.sayHi 메서드 내에서
- Person 생성자 함수의 지역 변수 `_age참조 불가`의 문제 발생
- `즉시 실행 함수를 사용해서 이를 해결`

```js
function Person(name, age) {
	this.name = name; //public
	let _age = age; // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
	// Person  생성자 함수의 지역 변수 _age를 참조 불가
	console.log(`Hi! My name is ${this.name}. I am ${_age}`);
};
```

- 이때 `Person.prototype.sayHi` 메서드 내에서 `Person 생성자 함수`의
- 지역 변수 `_age를 참조할 수 없는 문제`가 발생하게 됨
- 다음과 같이 `즉시 실행 함수`를 사용하여
- 1. Person 생성자 함수와
- 2. Person.prototype.sayHi 메서드를 하나의 함수 내에 합치기

```js
const Person = function () {
	let _age = 0; //private

	// 생성자 함수
	function Person(name, age) {
		this.name = name; // public
		_age = age;
	}

	// 프로토타입 메서드
	Person.prototype.sayHi = function () {
		console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
	};
	// 생성자 함수를 반환
	return Person;
};

const me = new Person('Lee', 20);
my.sayHi(); // Hi my name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined
```

- 위 패턴을 사용하면 public, private, protected 같은
- 접근 제한자를 사용하지 않는 JS에서도 정보 은닉이 가능한 것 처럼
- 보이게 됨

- 즉시 실행 함수가 반환하는 `Person 생성자 함수`와
- `Person 생성자 함수`의 `인스턴스가 상속받아 호출`하게 될
- `Person.prototype.sayHi 메서드` : 즉시 실행 함수가 종료된 이후 호출
- 하지만 `Person 생성자 함수`와 `sayHi 메서드`는 `이미 종료`되어
- `즉시 실행 함수의 지역 변수의 _age`를 `참조할 수 있는 클로저`

> 하지만 위 코드도 생성자 함수가 여러 개의 인스턴스를 생성하는 경우
> 오류가 발생하게 됨

- 이는 `Person.prototype.sayHi` 메서드 :
- 단 한 번 생성되는 클로저이기 때문에 발생
- `Person.prototype.sayHi` 메서드 : `즉시 실행 함수가 호출될 때 생성`
- 메서드 → 자신의 상위 스코프인 즉시 실행 함수의 실행 컨텍스트의
- `렉시컬 환경의 참조`를 → [[Environment]]에 저장하여 기억
- 따라서 어떤 인스턴스를 생성하더라도 `동일한 상위 스코프를 사용`하게 됨

> 결론적으로 JS : 정보 은닉을 완전하게 지원하지 않음

- 21년 1월 기준 `클래스에 private 필드를 정의`가 가능해짐

### 24.6 자주 발생하는 실수

- 아래는 `클로저를 사용할 때 자주 발생할 수 있는 실수`를 보여주는 예시

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
	funcs[i] = function () {
		return i;
	}; // -1
}

for (var j = 0; j < funcs.length; j++) {
	console.log(funcs[j]()); // -2
}
```

- 첫 번째 for 문의 코드 블록내 1 함수가 funcs의 배열 요소로 추가
- 그리고 두 번째 for문에서 함수를 순차적으로 호출
- 그러나 0,1,2를 반환할 것 으로 기대했던 결과는 그렇지 않음

- var 키워드로 선언한 i 변수 → `전역 변수`임
- 고로 `블록 레벨 스코프 X` → `함수 레벨 스코프`를 가지게 됨
- 배열의 요소로 추가한 함수를 호출하면 : 전역 변수 i를 참조하여
- i의 값 3이 출력됨

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
	funcs[i] = (function (id) {
		return function () {
			// -1-
			return id;
		};
	})(i);
}

for (var j = 0; j < funcs.length; j++) {
	console.log(funcs[j]());
}
```

- 1에서 즉시 실행 함수 : 전역 변수 i에 현재 할당되어 있는
- 값을 인수로 전달받아 → 매개변수 id에 할ㄹ당한 후
- 중첩 함수를 반환하고 종료
- 즉시 실행 함수가 반환한 함수 : funcs 배열에 순차적으로 저장

- 이때 즉시 실행 함쉬의 매개변수 id :
- 즉시 실행 함수가 반환한 `중첩 함수의 상위 스코프에 존재`
- 즉시 실행 함수가 반환한 중첩 함수 : 자신의 상위 스코프
- `(즉시 실행 함수의 렉시컬 환경)`을 기억하는 → `클로저`
- 매개변수 id : 즉시 실행 함수가 반환한 `중첩 함수에 묶여있는 자유변수`
- 그 값이 유지가 됨

- JS 함수 레벨 스코프 특성으로 인해
- for 문의 변수 선언문 → var 키워드로 선언한 변수가
- 전역 변수가 되기 때문에 발생하는 현상
- ES6의 `let 키워드를 사용`하면 → 이와 같은 `번거로움 없음`

```js
const funcs = [];

for (let i = 0; i < 3; i++) {
	funcs[i] = function () {
		return i;
	};
}

for (let i = 0; i < funcs.length; i++) {
	console.log(funcs[i]()); // 0 1 2
}
```

- for 문의 변수 선언문에서 `let 키워드 변수`를 사용 :
- `for 문의 코드 블록이 반복 실행`될 때마다
- for 문 코드 블록의 `새로운 렉시컬 환경이 생성`됨
- 만약 for 문의 코드 블록 내에서 정의한 함수가 있다면
- 함수의 상위 스코프 : for 문의 코드 블록이 반복 실행될 때마다
- 생성된 for 문 코드 블록의 `새로운 렉시컬 환경`임

- 이때 함수의 상위 스코프 : for 문의 코드 블록이 반복 실행될 때마다
- 식별자(for 문의 변수 선언문에서 초기화 변수 및 for 문의 코드 블록 내 선언한 지역변수)
- `값을 유지`를 시켜야함
- 이를 위해 for 문이 반복될 때마다 `독립적인 렉시컬 환경을 생성`하여
- `식별자의 값을 유지`해야 함

1. `for 문의 변수 선언문`에서 `let 키워드로 선언한 초기화 변수`를 사용한

   - for 문이 평가되면 → `새로운 렉시컬 환경을 생성`하고
   - `초기화 변수 식별자와 값을 등록`하게 됨
   - 새롭게 생성된 렉시컬 환경을 `현재 실행 중인 실행 컨텍스트`의
   - `렉시컬 환경으로 교체`함

2. for문이 실행되면 :

   - `새로운 렉시컬 환경` - `PER-ITERATION Lexical Environment`을 생성
   - for 문 `코드 블록 내의 식별자와 값을 등록`함
   - 새롭게 생성된 렉시컬 환경 → `현재 실행 중인 실행 컨텍스트 환경으로 교체`

3. for 문의 코드 블록의 반복 실행이 모두 종료되면
   - for 문이 `실행되기 이전의 렉시컬 환경`을
   - `실행 중인 실행 컨텍스트의 렉시컬 환경`으로 되돌림

- 이처럼 let, const 키워드를 사용하는 반복문
- `(for, for...in, for...of, while)` 은 코드 블록을 반복 실행 시 마다
- 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스냅숏을 찍는 것 처럼
- 저장하게 됨
- 이는 반복문의 코드 블록 내부에서 함수를 정의 할때 의미가 있음

> 블록 내부 함수 정의가 없는 반복문이 새로운 렉시컬 환경 :
> 아무것도 참조하지 않기 때문에 가비지 컬렉션의 대상이 됨

- 또 다른 방법으로 함수형 프로그래밍 기법인 고차 함수 사용 방법 존재
- 변수와 반복문의 사용을 억제할 수 있기 때문에
- 오류를 줄이고 가독성을 좋게 만듬

```js
// 요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를
// 요소로 추가하게됨
// 배열의 요소로 추가된 함수 : 모두 클로저
const funcs = Array.from(new Array(3), (_, i) => () => i); // (3) [f, f, f]

// 배열의 요소로 추가된 함수들을 순차적으로 호출
funcs.forEach((f) => console.log(f())); // 0 1 2
```

---
