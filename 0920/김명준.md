# 22/09/20

# 13장 스코프

---

### 13.1 스코프란?

: 식별자가 유효한 범위

→ 모든 식별자는 **자신이 선언된 위치에 의해** 다른 코드가 식별자 자신을 참조할 수 있는 **유효 범위가 결정됨** <br>
<br>

### 13.2 스코프의 종류

| 구분 | 설명                                                         | 스코프      | 변수      |
| ---- | ------------------------------------------------------------ | ----------- | --------- |
| 전역 | - 코드의 가장 바깥 영역<br> - 어디서든지 참조 가능           | 전역 스코프 | 전역 변수 |
| 지역 | - 함수 몸체 내부<br> - 자신의 지역과 하위 지역에서 참조 가능 | 지역 스코프 | 지역 변수 |

<br>

### 13.3 스코프 체인

: 스코프가 **계층적으로 연결**된 것. 최상위 스코프는 전역 스코프, 함수의 중첩별로 계층적인 구조를 가짐.

→ 변수 참조 시 JS 엔진은 **스코프 체인**을 통해 변수를 참조하는 스코프에서 시작하여 상위 스코프 방향으로 이동하며 **선언된 변수를 검색**
<br><br>

### 13.4 함수 레벨 스코프

: 코드 블록이 아닌 **함수에 의해서만 지역 스코프가 생성된다**는 의미

- var 키워드 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정
- ↔블록 레벨 스코프 : C나 자바 등에서 쓰임, 함수 몸체 뿐 아니라 모든 코드 블록(if, for, while, try/catch)에서 지역 스코프를 만듬
  <br><br>

### 13.5 렉시컬 스코프

: 함수를 어디서 정의했는지에 따라 상위 스코프를 결정(=정적 스코프)

↔ 동적스코프 : 함수를 어디서 호출했는지에 따라 상위 스코프 결정

```jsx
var x = 1;

funcion foo() {
	var x = 10;
	bar();
}

// 함수 bar()의 정의 시점에서 상위 스코프는 전역 스코프
function bar() {
	console.log(x);
}

foo();
bar();

---------------------------
> 1
> 1
```

<br>

# 14장 전역 변수의 문제점

---

### 14.1 변수의 생명 주기

- 변수의 생명 주기 : 메모리 공간이 확보된 시점부터 해제되어 반환되는 시점 까지
- 변수의 호이스팅은 엄밀히 말하면 **전역 변수 한정**
  - 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것 처럼 동작하기 때문
  - 호이스팅은 스코프 단위로 동작
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치
- 전역 변수의 생명 주기는 객체의 생명 주기와 일치
  <br><br>

### 14.2 전역 변수의 문제점

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합** 허용
- **코드 가독성 저하**, **의도치 않게 상태가 변경**될 위험성 증가
- 생명 주기가 길어 **리소스 오랜 기간 소비**
- 스코프 체인 상 종점에 존재하여 **검색 속도가 가장 느림**
- 파일이 분리되어 있어도 **하나의 전역 스코프를 공유**하므로 다른 파일에서 동일한 이름의 변수로 인한 문제 발생 가능
  <br><br>

### 14.3 전역 변수의 사용을 억제하는 방법

→ 변수의 스코프는 좁을수록 좋음

- 즉시 실행 함수
  - 단 한번만 호출되는 특성 → 모든 코드를 즉시 실행 함수로 감싸면 지역 변수
  - 주로 라이브러리에서 사용되는 방법
- 네임스페이스 객체
  - 전역에 네임스페이스 역할을 담당한 객체를 생성, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
  - 식별자 충돌 방지 효과는 있으나 객체 자체가 전역변수이므로 유용하진 않음
- 모듈 패턴

  - 클래스를 모방하여 관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈 형태로 만듬
  - 클로저 기능을 사용하여 전역 변수를 억제

  ```jsx
  var Counter = (function () {
    // private 변수
    var num = 0;

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
    return {
      increase() {
        return ++num;
      },
      decrease() {
        return --num;
      },
    };
  })();

  console.log(Counter.num); // undefined;

  console.log(Counter.increase()); // 1
  console.log(Counter.increase()); // 2
  console.log(Counter.decrease()); // 1
  console.log(Counter.decrease()); // 0
  ```

- ES6 모듈
  - 파일 자체의 독자적인 모듈 스코프를 제공 → 전역 변수 사용 불가
  - 예시
  ```jsx
  <script type="module" src="lib.mjs">
  	var m = 0;
  </script>
  <script>
  	console.log(m);  // Uncaught ReferenceError: m is not defined
  </script>
  ```

<br><br>

# 15장 let, const 키워드와 블록 레벨 스코프

---

### 15.1 var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 허용
  - 의도치않게 먼저 선언된 변수 값 변경될 가능성
- 함수 레벨 스코프
  - 함수의 코드 블록만 지역 스코프로 인정, 함수 외부는 전역 변수
- 변수 호이스팅 - 프로그램 흐름상 맞지 않음, 가독성 떨어뜨림, 오류 여지
  <br><br>

### 15.2 let 키워드

- 변수 중복 선언 금지
  - SyntaxError
- 블록 레벨 스코프
  - 모든 코드 블록을 지역 스코프로 인정 (함수, if, for, while, try/catch 등)
- 변수 호이스팅
  - 선언과 초기화가 **분리**되어 진행하여 호이스팅이 발생하지 않는 것 처럼 동작 → ReferenceError
  - 일시적 사각지대 : 스코프의 시작 지점부터 초기화 시작 지점까지 → 변수를 참조할 수 없은 구간
- 전역 객체와 let - 전역 변수와 객체는 window의 프로퍼티 - let은 window의 프로퍼티가 아님
  <br><br>

### 15.3 const 키워드

- 선언과 초기화
  - const 변수는 **선언과 동시에 초기화** 해야함
- 재할당 금지
  - 그러나 **불변은 아님**
- 상수
  - 원시 값 할당 시 변경방법 X
- const 키워드와 객체 - const 변수에 객체 할당 시 값 변경 가능, 객체는 변경 가능 값
  <br><br>

### 15.4 “var” vs “let” vs “const”

- var : 권장하지 않음
- const : 의도치 않은 재할당 방지 → 안전
- let : 재할당이 필요한 경우 한정 사용 권장
