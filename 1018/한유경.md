# 22. this

## 22.1 this 키워드
- 객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 다우니로 묶은 복합적인 자료구조
- 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 함
  <br> **-> 자신이 속한 객체를 가리키는 식별자를 참조할 필요 있음**

- **this**: 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
  <br>this 바인딩은 함수 호출 방식에 의해 동적으로 결정

> ## 왜 this가 필요한가?
> this가 없다면 아래와 같은 문제가 있다.
> 
> 생성자 정의 시점에서는 아직 인스턴스가 생성되지 않았으므로 인스턴스의 식별자를 알 수 없다.
> 따라서 this라는 특수한 식별자를 생성될 인스턴스의 식별자로 사용한다.
> ```javascript
> function Foo(x) {
>   // 생성자 선언 시점에서는 인스턴스를 가리키는 식별자를 알 수 없음!
>   ????.x = x;
> }
> var foo = new Foo(100);
> ```

> ## this가 가리키는 대상
> 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값이 동적으로 결정된다.
> - 객체 리터럴의 this : 객체 호출한 객체
> - 생성자 함수의 this : 생성자 함수가 생성할 인스턴스

<br>

## 22.2 함수 호출 방식과 this 바인딩
- this 바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.

> ## 렉시컬 스코프와 this 바인딩의 결정 시기
> - 렉시컬 스코프 : 함수 정의 평가되어 함수 객체 생성되는 시점
> - this 바인딩 : 함수 호출 시점

- 동일한 함수일지라도, 호출 방식에 따라 this 바인딩이 달라질 수 있다.
  - 일반 함수 호출 : this - 전역 객체(window)
  - 메서드 호출 : this - 호출한 객체
  - 생성자 함수 호출 : this - 생성할 인스턴스
  - Function.prototype.apply/call/bind 메서드에 의한 간접 호출 : this - 함수 내부의 인수에 의해 결정
- **이때 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.**

### apply/call/bind 메서드
- apply/call
  - this로 사용할 객체와 인수 리스트를 전달받아 함수 호출
```javascript
function getThisBinding() {
  return this;
}

const thisArg = { a : 1 };
console.log(getThisBinding());  // window

console.log(getThisBinding.apply(thisArg)); // { a: 1 }
console.log(getThisBinding.call(thisArg)); // { a: 1 }

// call과 apply의 차이
function getThisBinding2() {
  console.log(arguments);
  return this;
}

console.log(getThisBinding2.apply(thisArg, [1, 2, 3]));
// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
// { a: 1 }
console.log(getThisBinding2.call(thisArg, 1, 2, 3)); // { a: 1 };
// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
// { a: 1 }
```
- bind
  - 함수 호출 X,  첫 번째 인수로 전달한 값으로 this 바인딩 교체된 함수 생성하여 반환
```javascript
function getThisBinding() {
  return this;
}

const thisArg = {a : 1};
console.log(getThisBinding.bind(thisArg));    // getThisBinding
console.log(getThisBinding.bind(thisArg)());    // { a: 1 }
```

<br>

# 23. 실행 컨텍스트
## 23.1 소스코드의 타입
|소스코드의 타입|설명|
|----|-----------------|
|전역 코드|전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 미포함|
|함수 코드|함수 내부에 존재하는 소스코드.<br> 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 미포함|
|eval 코드|빌트인 전역 함수인 eval 함수에 인수로 전달되어 실해되는 소스코드|
|모듈코드|모듈 내부에 존재하는 소스코드. 모튤 내부의 함수, 클래스 등의 내부 코드 미포함|

- 소스코드를 구분하는 이유 : 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문

## 23.2 소스코드의 평가와 실행
- 모든 소스코드는 앞서 평가 과정을 거치며 코드 실행 준비를 한다.
  1. 소스코드 평가 과정
      - 실행 컨텍스트 생성
      - 변수, 함수 등의 선언문만 실행 -> 식별자를 키로 스코프에 등록 
  2. 소스코드 실행
      - 선언문을 제외한 소스코드가 순차적으로 실행(런타임 시작)

## 23.3 실행 컨텍스트의 역할
- 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.
  - 선언에 의해 생성된 모든 식별자를 스코프 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 함
  - 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 함
  - 현재 실행 중인 코드의 실행 순서를 변경 및 복귀가 가능해야 함
- **실행 컨텍스트**를 통해 이 모든 것을 관리한다.
- **실행 컨텍스트** : 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
  - 스코프, 식별자 등록 및 관리(렉시컬 환경)
  - 코드 실행 순서 관리(실행 컨텍스트 스택)

## 23.4 실행 컨텍스트 스택
- 실행 컨텍스트 스택(call stack)을 통해 생성된 실행 컨텍스트를 관리
- 코드 실행 순서를 관리
  
## 23.5 렉시컬 환경
- 랙시컬 환경은 식별자와 식별자에 바인된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조
- 실행 컨텍스트를 구성하는 컴포넌트
- 스코프와 식별자를 관리

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

## 23.7 실행 컨텍스트와 블록 레벨 스코프
