# 22/09/13

# 10장 객체 리터럴

---

### 10.1 **객체**

: 원시타입을 제외한 나머지 값(함수, 배열, 정규 표현식 등)

- 원시 값은 변경 불가능, 객체는 **변경 가능한 값**
- 객체는 0개 이상의 **프로퍼티**로 구성된 집합
    
    > 프로퍼티는 키(key)와 값(value)으로 구성됨
    프로퍼티 : 객체의 상태를 나타내는 값
    메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작
    > 
    
    ```jsx
    var counter = {
    	num = 0,                // 프로퍼티 키는 num, 값은 0
    	increase: function() {  // 메서드
    		this.num++;
    	}
    };
    ```
    

### 10.2 객체 리터럴에 의한 객체 생성

JavaScript 객체 생성 방법

- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)
- **객체 리터럴** : 중괄호 내에 0개 이상의 프로퍼티를 정의
    
    → 변수 할당 시점에 자바스크립트 엔진이 객체리터럴을 해석하여 객체 생성
    

> 객체 리터럴의 중괄호는 코드블록이 아님 → 세미콜론이 붙어야함.
> 

### 10.3 프로퍼티

: 객체는 프로퍼티의 집합, 프로퍼티는 키와 값으로 구성

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값
- 식별자 네이밍 규칙을 따르지 않는 이름은 따옴표(’’)사용

### 10.4 메서드

: 프로퍼티 값이 함수일 경우 일반함수와 구분을 위해 메서드라고 명명

→ 객체에 묶여있는 함수

> 메서드 내부의 this 키워드는 객체 자신을 가리키는 참조변수
> 

### 10.5 프로퍼티 접근

- 마침표 표기법( . )
    - person.name
- 대괄호 표기법([ … ])
    - person[’name’] → 반드시 따옴표로 감싼 문자열
    
    > 객체에 존재하지 않는 프로퍼티 접근 시 undefined 반환, RefferenceError 발생X
    > 

### 10.6 프로퍼티 값 갱신

: 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값 갱신

```jsx
var person = { name : 'Lee' };
person.name = 'Kim';
```

### 10.7 프로퍼티 동적 생성

: 존재하지 않는 프로퍼티에 값을 할당하면 동적으로 생성 및 할당

```jsx
var person = { name : 'Lee' };
person.age = 20;
```

### 10.8 프로퍼티 삭제

: delete 연산자는 객체의 프로퍼티를 삭제 → 존재하지 않을 시 에러 없이 무시

```jsx
var person = { name : 'Lee' };
delete person.name;
```

### 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

1. **프로퍼티 축약 표현** 
    - 프로퍼티 값으로 변수를 사용하는 경우, **변수 이름**과 **프로퍼티 키**가 동일한 이름일 때 **생략 가능**
    
    ```jsx
    let x = 1, y = 2;
    const obj = { x, y };  // x = 1, y = 2
    ```
    
2. **계산된 프로퍼티 이름**
    - 문자열(또는 변환가능 값)로 표현식을 사용해 프로퍼티 키를 동적 생성 가능
        
        → 단, 대괄호로 묶어야 함
        
    
    ```jsx
    var obj = {};
    obj['prop' + '-' + ++i] = i;
    obj['prop' + '-' + ++i] = i;
    obj['prop' + '-' + ++i] = i;
    console.log(obj);  // {prop-1: 1, prop-2: 2, prop-3: 3;}
    ```
    
3. 메서드 축약 표현
    - function 키워드를 생략한 축약 표현 사용 가능
    
    ```jsx
    const obj = {
    	name : 'Lee',
    	// sayHi: function() { console.log('Hi!' + this.name); }
    	sayHi() { console.log('Hi!' + this.name); }
    };
    ```
    

# 11장 원시 값과 객체의 비교

---

- 원시 값
    - 변경 불가능
    - 변수 할당 → 변수에 실제 값 저장
    - 값에 의한 전달
- 객체
    - 변경 가능
    - 변수 할당 → 변수에 참조 값이 저장
    - 참조에 의한 전달(원시값, 참조값 구분을 위한 용도, 포인터 개념X)

### 11.1 원시 값

: 원시 타입의 값, 변경 불가능한 값, 읽기 전용 값 → 변수가 아닌 값에 대한 진술

```jsx
var str = 'string';
str[0] = 'S';
console.log(str)  // string
```

### 11.2 객체

- 프로퍼티 개수 지정X, 동적으로 추가 및 삭제 가능, 제약X
    
    → 확보 메모리 공간 사전에 지정X
    
- 해시 테이블 처럼 구현하지만, 성능을 위해 더 나은 방법을 사용 → 히든클래스
- 여러 개의 식별자가 하나의 객체를 공유할 수 있음 → 부작용 존재
    
    
    ```jsx
    var p1 = { name : 'Lee' };
    var p2 = { name : 'Lee' };
    console.log(p1 === p2);  // false -> 참조값 비교
    console.log(p1.name === p2.name);  // true -> 원시값 비교
    ```
    

# 12장 함수

---

: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것

### 12.2 함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성

### 12.3 함수 리터럴

: 함수는 객체, 일반 객체와 달리 호출할 수 있음

| 구성 요소 | 설명 |
| --- | --- |
| 함수 이름 | - 함수 이름은 식별자 → 식별자 네이밍 룰 준수
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자
- 함수 이름은 생략 가능, 이름이 있으면 기명함수, 없으면 익명(무명)함수 |
| 매개변수 목록 | - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
- 각 매개변수에는 함수 호출 시 지정한 인수가 순서대로 할당 → 순서에 의미 있음
- 매개변수는 함수 몸체 내에서 변수와 동일하게 취급 → 네이밍 룰 준수 |
| 함수 몸체 | - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록
- 함수 몸체는 함수 호출에 의해 실행 |

### 12.4 함수 정의

: 함수 호출 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것

| 함수 정의 방식 | 예시 |
| --- | --- |
| 함수 선언문 | function add(x, y) {
 return x + y;
}
// 함수 선언문은 함수 이름을 생략할 수 없다. |
| 함수 표현식 | var add = function(x, y) {
 return x + y;
} |
| Function 생성자 함수 | var add = new Function(’x’, ‘y’, ‘return x + y’); |
| 화살표 함수(ES6) | var add = (x,y) => x + y; |

→ 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당함

```jsx
	  // 식별자      // 함수 이름
var add = function add(x,y) {
 return x + y;
};
console.log(add(2, 5));  // add : 식별자
```

- 함수 생성 시점과 함수 호이스팅

```jsx
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) { return x + y; }
// 함수 표현식
var sub = function (x, y) { return x - y; }
```

→ 변수 할당문의 값은 할당문이 실행되는 시점, 런타임에 평가되므로 함수 리터럴도 실행되는 시점에 평가되어 함수객체가 된다.

→ 함수 표현식으로 정의하면 변수 호이스팅이 발생!

### 12.5 함수호출

: 함수 호출은 표현식

### 12.6 참조에 의한 전달과 외부상태의 변경

![image](https://user-images.githubusercontent.com/100829030/189954972-2bb767c4-e9b3-4a05-bd20-6e3fc7170db5.png)

> 여러 변수가 같은 객체를 참조하여 객체의 변경을 추적하는 것을 방지해야함
→ 옵저버 패턴 등을 통해 객체 참조를 공유하는 이들에게 변경 통지
→ 불변 객체로 만들어 사용 : deep copy
> 

### 12.7 다양한 함수의 형태

- 즉시 실행 함수 : 함수 **정의와 동시에 즉시 호출**, 단 한번만 호출됨 ex) 익명함수
- 재귀 함수 : 함수가 **자기 자신을 호출하는 함수**
- 중첩 함수(내부 함수) : **함수 내부에 정의된 함수** (중첩 ****함수를 포함하는 함수 : 외부함수)
- 콜백 함수 : 함수의 **매개변수를 통해 다른 함수의 내부로 전달되는 함수**
- 고차 함수 : 매개변수를 통해 **함수의 외부에서 콜백 함수를 전달받은 함수**
    
    → 콜백 함수를 자신의 일부분으로 합성
    
    → 콜백 함수의 호출 시점을 결정해서 호출
    
- 순수 함수 : **외부 상태**에 의존하지 않고 변경하지 않는, **부수 효과가 없는 함수**
- 비순수 함수 : ↔ 순수함수
