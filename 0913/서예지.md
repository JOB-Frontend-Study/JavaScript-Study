# 10. 객체 리터럴

### 객체

- 원시 값을 제외한 모든 값
- 0개 이상의 프로퍼티로 이루어짐
- 프로퍼티와 메서드로 구성됨
    - 프로퍼티 : 객체의 상태를 나타내는 값 (key : value)
        - 키 - 모든 문자열 or 심벌 값 (식별자 네이밍 규칙 준수하지 않을 경우 따옴표로 묶는다)
        - value - 모든 값
        - 키를 중복 선언하면 나중에 선언한게 덮어씀
        - 접근 : 마침표`person.name` or 대괄호`person[ ’name’ ]`
        - ES6 부터는 변수 사용할 경우 키 생략 가능
    - 메서드 : value자리에 들어가는 함수
        - 객체에 묶여있는 함수

### 객체 생성 방법

- 객체 리터럴
    - 중괄호 내에 0개 이상의 프로퍼티 정의
- object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)


# 11. 원시 값과 객체의 비교

### 원시 값

- 변경 불가능한 값
- 원시 값을 변수에 할당하면 실제 값 저장
- 원시 값 변수를 다른 변수에 할당하면 원본 원시 값이 복사되어 전달
- 새로운 원시 값을 재할당하면 새로운 메모리 공간 확보 → 거기에 원시 값 저장 → 주소 이동
- 문자열이 변경 불가능한 이유 - 문자열은 길이에 따라 메모리 공간의 크기가 결정됨 (특정 인덱스도 변경 불가능)
- 값에 의한 전달 → 다른 주소 가짐 (깊은 복사 같은 느낌)

### 객체

- 프로퍼티 개수도 모르고 value 제약도 없음 —> 원시 값처럼 미리 메모리 공간을 정해 둘 수 없음
- 관리 방식 → 해시테이블과 유사
- 변수의 주소로 메모리 공간에 접근하면 참조 값(객체가 있는 주소 값)을 얻을 수 있음
- 크기도 몰라, 복사 생성 비용도 많이 들어 ,,, 즉, 메모리를 효율적으로 사용하기 힘들고 성능이 나빠져서 객체는 변경 가능한 값으로 설계된 것
- 단점 —> 여러 개의 식별자가 하나의 객체를 공유할 수 있음(얕은 복사 & 깊은 복사)
- 얕은 복사 : `{ … }`
- 깊은 복사 : `lodash`의 `cloneDeep` 활용
- 참조에 의한 전달 → 객체가 있는 주소 값이 복사되어 전달 (얕은 복사 느낌)
