# 04장 변수

### 4.1 변수

: 값을 저장하기 위해 확보한 메모리 공간을 지칭

### 4.2 식별자

: 메모리 주소를 기억하는 값 → ex) 변수, 함수, 클래스 등

### 4.3 변수 선언

- var            → ES6 이전 유일
- let, const  → ES6 이후 출시

| 키워드 | 구분 | 선언위치 | 재선언 |
| --- | --- | --- | --- |
| var | 변수 | 전역 스코프 | 가능 |
| let | 변수 | 해당 스코프 | 불가능 |
| const | 상수 | 해당 스코프 | 불가능 |
- 변수 선언하지 않고 사용 시 → ReferenceError(참조에러)

### 4.4 변수 호이스팅

: 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 특징

→ 변수 선언은 런타임보다 이전 단계에서 먼저 실행됨 

### 4.5 값의 할당

: 변수 선언은 런타임 이전, 값의 할당은 런타임에 이루어짐

```jsx
console.log(score);

score = 80;
var score;

console.log(score);

> undefined
> 80
```

### 4.6 값의 재할당

: 새로운 메모리 공간을 확보하고 값을 재할당

→ 재할당 이전 값들은 가비지컬렉터에 의해 메모리에서 자동해제(시점 예측 불가)

### 4.7 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함 할 수 있다.
- 단, 숫자로 시작은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다. (if, else, catch, break 등)
- 변수, 함수 : 카멜 케이스 (camelCase)
- 클래스, 생성자 함수 : 파스칼 케이스 (PascalCase)

# 05장 표현식과 문

### 5.1 값

: 식이 평가되어 생성된 결과 

→ 평가 : 식을 해성해서 값 생성

### 5.2 리터럴

: 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(’ ’, “ ”, ., [ ], { } 등)를 사용해 값을 생성하는 표기법

| 리터럴 | 예시 | 비고 |
| --- | --- | --- |
| 정수 | 100 |  |
| 부동소수점 | 10.5 |  |
| 2진수 | 0b01 | 0b로 시작 |
| 8진수 | 0o101 | 0o로 시작, ES6에서 도입 |
| 16진수 | 0x41 | 0x로 시작, ES6에서 도입 |
| 문자열 | ‘Hello’
”World” |  |
| boolean | true
false |  |
| null | null |  |
| undefined | undefined |  |
| 객체 | { name : ‘Lee’, adderss: ‘Seoul’ } |  |
| 배열 | [ 1, 2, 3 ] |  |
| 함수 | function() { } |  |
| 정규 표현식 | /[A-Z]+/g |  |

→ 자바스크립트는 런타임에 리터럴을 평가해 값을 생성

### 5.3 표현식

: 값으로 평가될 수 있는 문

→ 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조함

→ 리터럴은 값으로 평가되므로 리터럴도 그 자체로 표현식

### 5.4 문

: 프로그램을 구성하는 기본 단위이자 최소 실행 단위

→ 프로그램 : 문의 집합

→ 프로그래밍 : 문을 작성하고 순서에 맞게 나열하는 것

- 토큰 : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 → 문은 여러 토큰으로 구성됨
    - ex) 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등

### 5.5 세미콜론&자동 삽입 기능

: 자바스크립트는 세미콜론 자동 삽입 기능(Automatic Semicolon Insertion)이 암묵적으로 수행

→ 세미콜론은 문의 종료를 나타냄

→ 그래도 직접 사용을 권장하는 분위기

### 5.6 표현식인 문과 표현식이 아닌 문

: 표현식은 문의 일부일 수도 있고, 자체로 문이 될 수도 있다

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아님
var x;
// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식

// 표현식이면서 완전한 문
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없음
var foo = var x;
```

→ 구별법 : 변수에 할당해보기

- 완료 값 : 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력함
    - → 완료 값은 표현식 평가 결과가 아님, 변수 할당 불가, 참조 불가
    
    ```jsx
    > var foo = 10;
    < undefined
    > if (true) {}
    < undefined
    > foo + 10;
    < 20
    ```

# 06장 데이터 타입

| 구분 | 데이터 타입 | 설명 |
| --- | --- | --- |
| 원시타입 | number | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입 |
|  | string | 문자열 |
|  | boolean | 논리적 참과 거짓 |
|  | undefined | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
|  | null | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
|  | symbol | ES6에서 추가된 7번째 타입 |
| 객체타입 |  | 객체, 함수, 배열 등 |

### 6.1 숫자 타입

: 정수, 실수 구분 없이 모두 number, 64비트 부동소수점 형식 사용

- Infinity : 10 / 0
- -Infinity : 10 / -0
- NaN : 숫자와 다른 타입 연산

### 6.2 문자열 타입

: 텍스트 데이터를 나타내는데 사용, (’ ‘), (” “), (\` `) 등으로 감싸서 표현

→ 따옴표로 감싸지 않으면 문자열을 키워드나 식별자 같은 토큰으로 인식

### 6.3 템플릿 리터럴

: ES6부터 백틱(\` `)을 사용하는 새로운 문자열 표기법

- 멀티라인 문자열 : 줄바꿈 등을 스케이프 시퀀스(\r, \t, \b 등) 없이 있는 그대로 적용
- 표현식 삽입 : ‘${ }’로 표현식을 감싸서 문자열 어느 위치에나 삽입 가능

### 6.4 불리언 타입

: 참, 거짓

### 6.5 Undefined 타입

: undefined가 유일한 값 

→ 자바스크립트가 변수를 초기화한 값 → 임의로 초기화 한 적이 없는 변수

### 6.6 null 타입

: null이 유일한  (Null, NULL 등과는 다른 값)

→ 의도적으로 변수에 값이 없다는 것을 명시할 때 쓰임

→ 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함

### 6.7 심벌 타입

: 변경 불가능한 원시 타입의 값 (ES6 이후 출시)

→ 심벌 값은 다른 값과 중복되지 않는 유일무이한 값, 함수를 호출해 생성

### 6.8 객체 타입

:  앞선 원시 타입 6가지 외에 모든 타입

→ 자바스크립트를 이루고 있는 거의 모든 것이 객체

### 6.9 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 6.10 동적 타이핑

: 자바스크립트 변수는 할당에 의해 타입이 결정, 재할당에 의해 변수 타입이 동적으로 변함

→ 편하지만, 변수 값 추적이 어렵고 값을 확인하기 전엔 타입을 확신할 수 없음

→ 유연성은 높지만 신뢰성은 떨어짐

# 07장 연산자

: 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

| 연산자 구분 | 예시 |
| --- | --- |
| 산술 | 5 * 4 |
| 문자열 연결 | ‘My name is’ + ‘Lee’ |
| 할당 | color = ‘red’ |
| 비교 | 3 > 5 |
| 논리 | true && false |
| 타입 | typeof ‘Hi’ |

| 우선 순위 | 연산자(쉼표로 구분) |
| --- | --- |
| 1 | ( ) (그룹화) |
| 2 | [ ], new, ( ) (함수 호출), ?.(옵셔널 체이닝) |
| 3 | new(인수 없이) |
| 4 | ++(후위), --(후위) |
| 5 | !, ~, +(단항), -(단항), ++(전위), --(전위), typeof, void, delete, await |
| 6 | ** |
| 7 | *, /, % |
| 8 | +(이항), -(이항) |
| 9 | <<, >>, >>> |
| 10 | <, <=, >, >=, in, instanceof |
| 11 | ==, !=, ===, !== |
| 12 | & |
| 13 | ^ |
| 14 | | |
| 15 | && |
| 16 | || |
| 17 | ? : (삼항 연산자) |
| 18 | =, +=, -=, **=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, |= |
| 19 | yield, yield* |
| 20 | ,(쉼표) |

# 08장 제어문

: 조건문이나 반복문에 사용, 코드의 실행 흐름을 인위적으로 제어

### 8.1 블록문

: 0개 이상의 문을 중괄호로 묶은 것 (코드 블록 or 블록) → 하나의 실행 단위

- 단독 사용 가능하나, 일반적으로 제어문이나 함수를 정의할 때 사용
- 블록문은 자체 종결성을 갖기 때문에 끝에 세미콜론 X

### 8.2 조건문

: 주어진 조건식의 평가 결과에 따라 코드 블록 실행 여부를 결정 (if 문, switch 문)

- 조건식은 boolean 값으로 평가 → boolean 값이 아닐 시 암묵적 타입 변환

### 8.3 반복문

: 주어진 조건식의 평가 결과가 거짓이 아닐 동안 코드 블록을 실행 

- for
- while
- do…while
- forEach (콜백함수)
- for…in (객채의 키)
- for…of (객체의 값)

# 09장 타입 변환과 단축 평가

### 9.1 타입 변환

- 명시적 타입 변환(타입 캐스팅) : 개발자가 의도적으로 값의 타입을 변환하는 것
- 암묵적 타입 변환(타입 강제 변환) : 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것

### 9.2 암묵적 타입 변환

: 표현식을 평가할 때 가급적 에러를 발생시키지 않도록 암묵적 타입 변환

```jsx
'10' + 2  // -> '102'
5 * '10'  // -> 50
'10' - 2  // -> 8
'5' / 2   // -> 2.5

!0  // -> true
if(1) { }
```

- ‘문자열’ + ‘다른 타입’ → ‘문자열’로 타입 변환
- ‘-’, ‘*’, ‘/’ 의 경우 숫자로 타입 변환 후 연산, 변환 불가한 경우 결과 NaN
- 단항 연산자는 숫자 타입의 값으로 암묵적 타입 변환

| 단항 연산자 예시 | 결과 |
| --- | --- |
| +’’  | 0 |
| +’1’ | 1 |
| +’string’ | NaN |
| +true | 1 |
| +null | 0 |
| +undefined | NaN |
| +Symbol() | TypeError : Cannot convert a Symbol value to a number |
| +{} | NaN |
| +[] | 0 |
| +[10, 20] | NaN |
| +(function(){}) | NaN |
- false로 취급되는 값
    - false
    - undefined
    - null
    - 0, -0
    - NaN
    - ‘’(빈 문자열)

### 9.3 명시적 타입 변환

: 개발자의 의도에 따라 명시적으로 타입을 변경

→ 방법 1. 표준 빌트인 생성자 함수를 new 연산자 없이 호출

→ 방법 2. 빌트인 메서드를 사용하는 방법

- 문자열
    - String(1); → ‘1’
    - (1).toString(); → ‘1’
- 숫자
    - Number(’1’); → 1
    - parseInt(’1’); → 1
    - +’1’; → 1
    - ‘1’ * 1; → 1
- Boolean
    - Boolean(’x’); → true
    - !!’x’ → true
    - !!’NaN’ → true

### 9.4 단축 평가

### **9.4.1 논리 연산자를 사용한 단축 평가**

: ‘&&’, ‘||’ 연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환

→ 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략

| 단축 평가 표현식 | 평가 결과 |
| --- | --- |
| true || anything | true |
| false || anything | anything |
| true && anything | anything |
| false && anything | false |

```jsx
if(done)
	message = '완료';

message = done && '완료';
```

- 에러 방지

```jsx
// 객체를 가리키길 기대하는 변수가 null || undefined가 아닌지 확인하고 프로퍼티를 참조
var elem = null;
var val = elem.value;  // TypeError: Cannot read property 'value' of null

var elem = null;
var val = elem && elem.value;  // -> null

// 함수 호출 시 매개변수 기본값을 단축평가를 사용해 설정
function getStringLength(str) {
	str = str || '';
	return str.length;
}

// ES6의 매개변수 기본값 설정
function getStringLength(str = '') {
	return str.length;
}

getStringLength(); // -> 0
getStringLength('hi'); // -> 2
```

### 9.4.2 옵셔널 체이닝 연산자 (?.)

: 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환, 아니면 우항의 프로퍼티 참조

→ ES11에서 도입

```jsx
var elem = null;

var val = elem?.value;
console.log(val);  // -> undefined

var elem = '';
var val = elem && elem.value;
console.log(val);  // -> '' : 객체로 평가되기 때문
```

null과 undefined 외에 false값들이면 우항의 프로퍼티 참조를 이어감

```jsx
var elem = '';

var val = elem?.value;
console.log(val);  // -> 0
```

### 9.4.3 null 병합 연산자 (??)

: 좌항의 피연산자가 null또는 undefined인 경우 우항의 피연산자를 반환, 아니면 좌항의 피연산자 반환 → ES11에서 도입

```jsx
// 변수에 기본값을 설정할 때 유용
var foo = null ?? 'default';
console.log(foo); // -> "default"
```

```jsx
// 기존 논리 연산자의 경우 0이나 ''도 유효값으로 필요할 때 구분할 수 없음
var foo = '' || 'default';
console.log(foo); // -> "default"
```

null과 undefined 외에 false값들이어도 좌항의 피연산자를 그대로 반환