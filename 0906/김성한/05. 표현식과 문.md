## 표현식과 문

---

<br />

#### 값

- `값` = 식이 평가되어 생성된 결과
```js
var sum = 10 + 20;
```
- 변수 `sum` 에는 10+20이 형가되어 생성된 숫자 값 30이 할당된다.

- 값은 다양한 방법으로 생성할 수 있다. 위 예제처럼 식으로 생성할 수도 있지만 가장 기본적인 방법은 `리터럴`을 이용하는 것이다.

<br />

#### 리터럴

- `리터럴` 은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

```js
3
```

- 위 처럼 3은 단순한 아라비아 숫자가 아니라 `숫자 리터럴` 이다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다. 

- 이처럼 리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 미리 약속된 기호('',"", ., [], {}, (), // 등)로 표기한 코드다.
- 자바스크립트 엔진은  실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.
- 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법

```js
여기서 한번 더 정리하자면 

자바스크립트 엔진에서 변수 선언은 런타임 이전에 일어나고 값의 할당은 런타임에 일어난다. 그리고 추가적으로 리터럴에 대한 연산(평가)는 런타임에 진행하므로

var result = 30 + 20;

이라는 코드가 있다면 런타임 이전에 var result 가 선언되어 메모리에 undefined가 할당되고, 런타임에 30 + 20 의 리터럴을 평가해 50이라는 값을 만든다음 동시에 result에 할당하는 순서라고 생각할 수 있다. 
```

리터럴의 종류는 교재 p.52를 살펴보자

<br />

#### 표현식

- 표현식은 값으로 평가될 수 있는 `문(statement)`이다.
- 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

```js
var score = 100;
```

- 여기서 100은 숫자 리터럴이다.
- 이 100 은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴은 그 자체로 `표현식`이다. 

```js
//리터럴 표현식
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정 )
sum
person.name
arr[1]

//연산자 표현식
10 + 20
sum = 10
sum !== 10

//함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

- 즉, 값으로 평가될 수 있는 문은 모두 표현식이다.

<br />

#### 문 (statement)

- `문`과 `표현식`을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고, 실행 결과를 예측하는데 도움이 된다.
- `문`은 프로그램을 구성하는 `기본 단위`이자 `최소 실행 단위`다.
- 문은 여러 `토큰`으로 구성되며, `토큰`이란 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 
Ex) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;)이나 마침표(.)등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다. 

```js
var sum = 1 + 2 ; 
```
- 토큰 : var / sum / 1 / + / 2 / ;
- 총 6개의 토큰이 있고 이들을 하나로 합친 위의 코드를 문이라고한다.
- 문에는 선언문, 할당문, 조건문, 반복문 등이 있고 문을 명령문이라고도 부른다. => 문을 실행하면 무슨 일인가 일어나기에.. 

```js
// 변수 선언문
var x; 

// 할당문
x = 5;

// 함수 선언문
function foo()
{
    //...
}

// 조건문 
if (x>1)
{
    console.log(x);
}

// 반복문
for(var i = 0; i < 2; i++)
{
    console.log(i);
}
```

- 정리하자면 `문`은 코드 명령(표현식을 포함할수도 있다.)
- `표현식`은 값을 나타내는 코드단위

<br />

#### 세미콜론과 세미콜론 자동 삽입 기능 

- 자바스크립트에서 문의 끝에 붙이는 세미콜론은 옵션이다. 즉, 세미콜론은 생략가능하다. 
- 이는 자바스크립트 엔진이 소스코드를 해석할때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 `세미콜론 자동 삽입 기능( ASI)`이 암묵적으로 수행되기 때문이다.
- 하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있다. 

```js
function foo()
{
    return 
    {}
    // ASI의 동작 결과 => 
    // return;
    // {};

    // 개발자의 예측 => 
    // return {};
}

console.log(foo()) // undefined

var bar = function () {}
(function () {})();

// ASI 의 동작 결과 => 
// var bar = function() {}(function() {}) ();

// 개발자의 예측 =>
// var bar = function() {};(function() {}) ();

// TypeError...
```

- 위와 같은 상황들이 발생할 수 있기에 가급적 세미콜론을 붙이도록 하자 
- 심지어 TC39(ECMAScript 기술 위원회)도 세미콜론 사용을 권장하고 있으니 그냥 닥치고 사용하자 

<br />

#### 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일수도 있고, 그 자체로도 문이 될 수 도 있다. 

```js
var x;
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.

x = 1 + 2;
// 위의 문은 표현식이면서 완전한 문이다.
```

- 문에는 표현식인 문과 표현식이 아닌 문이 있다.
- 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
  
```js
var foo = x = 100;
console.log(foo); // 100
```
- x = 100 은 표현식인 문으로 해석할 수 있다.

#### 완료값
- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 
- 이를 `완료값`이라고 한다.
- 완료값은 표현식의 평가결과가 아니다. 따라서 다른값과 같이 변수에 할당할 수 없고 참조할 수도 없다.
- 크롬 개발자 도구에서 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.

